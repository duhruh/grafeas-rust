// This file is generated by rust-protobuf 2.6.0. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

#[derive(PartialEq,Clone,Default)]
pub struct BuildProvenance {
    // message fields
    pub id: ::std::string::String,
    pub project_id: ::std::string::String,
    pub commands: ::protobuf::RepeatedField<Command>,
    pub built_artifacts: ::protobuf::RepeatedField<Artifact>,
    pub create_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub start_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub end_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub creator: ::std::string::String,
    pub logs_uri: ::std::string::String,
    pub source_provenance: ::protobuf::SingularPtrField<Source>,
    pub trigger_id: ::std::string::String,
    pub build_options: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    pub builder_version: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BuildProvenance {
    fn default() -> &'a BuildProvenance {
        <BuildProvenance as ::protobuf::Message>::default_instance()
    }
}

impl BuildProvenance {
    pub fn new() -> BuildProvenance {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // string project_id = 2;


    pub fn get_project_id(&self) -> &str {
        &self.project_id
    }
    pub fn clear_project_id(&mut self) {
        self.project_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_project_id(&mut self, v: ::std::string::String) {
        self.project_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_project_id(&mut self) -> &mut ::std::string::String {
        &mut self.project_id
    }

    // Take field
    pub fn take_project_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.project_id, ::std::string::String::new())
    }

    // repeated .grafeas.v1beta1.provenance.Command commands = 3;


    pub fn get_commands(&self) -> &[Command] {
        &self.commands
    }
    pub fn clear_commands(&mut self) {
        self.commands.clear();
    }

    // Param is passed by value, moved
    pub fn set_commands(&mut self, v: ::protobuf::RepeatedField<Command>) {
        self.commands = v;
    }

    // Mutable pointer to the field.
    pub fn mut_commands(&mut self) -> &mut ::protobuf::RepeatedField<Command> {
        &mut self.commands
    }

    // Take field
    pub fn take_commands(&mut self) -> ::protobuf::RepeatedField<Command> {
        ::std::mem::replace(&mut self.commands, ::protobuf::RepeatedField::new())
    }

    // repeated .grafeas.v1beta1.provenance.Artifact built_artifacts = 4;


    pub fn get_built_artifacts(&self) -> &[Artifact] {
        &self.built_artifacts
    }
    pub fn clear_built_artifacts(&mut self) {
        self.built_artifacts.clear();
    }

    // Param is passed by value, moved
    pub fn set_built_artifacts(&mut self, v: ::protobuf::RepeatedField<Artifact>) {
        self.built_artifacts = v;
    }

    // Mutable pointer to the field.
    pub fn mut_built_artifacts(&mut self) -> &mut ::protobuf::RepeatedField<Artifact> {
        &mut self.built_artifacts
    }

    // Take field
    pub fn take_built_artifacts(&mut self) -> ::protobuf::RepeatedField<Artifact> {
        ::std::mem::replace(&mut self.built_artifacts, ::protobuf::RepeatedField::new())
    }

    // .google.protobuf.Timestamp create_time = 5;


    pub fn get_create_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.create_time.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::default_instance())
    }
    pub fn clear_create_time(&mut self) {
        self.create_time.clear();
    }

    pub fn has_create_time(&self) -> bool {
        self.create_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_create_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.create_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_create_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.create_time.is_none() {
            self.create_time.set_default();
        }
        self.create_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_create_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.create_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // .google.protobuf.Timestamp start_time = 6;


    pub fn get_start_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.start_time.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::default_instance())
    }
    pub fn clear_start_time(&mut self) {
        self.start_time.clear();
    }

    pub fn has_start_time(&self) -> bool {
        self.start_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.start_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_start_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.start_time.is_none() {
            self.start_time.set_default();
        }
        self.start_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_start_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.start_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // .google.protobuf.Timestamp end_time = 7;


    pub fn get_end_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.end_time.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::default_instance())
    }
    pub fn clear_end_time(&mut self) {
        self.end_time.clear();
    }

    pub fn has_end_time(&self) -> bool {
        self.end_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_end_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.end_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_end_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.end_time.is_none() {
            self.end_time.set_default();
        }
        self.end_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_end_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.end_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // string creator = 8;


    pub fn get_creator(&self) -> &str {
        &self.creator
    }
    pub fn clear_creator(&mut self) {
        self.creator.clear();
    }

    // Param is passed by value, moved
    pub fn set_creator(&mut self, v: ::std::string::String) {
        self.creator = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_creator(&mut self) -> &mut ::std::string::String {
        &mut self.creator
    }

    // Take field
    pub fn take_creator(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.creator, ::std::string::String::new())
    }

    // string logs_uri = 9;


    pub fn get_logs_uri(&self) -> &str {
        &self.logs_uri
    }
    pub fn clear_logs_uri(&mut self) {
        self.logs_uri.clear();
    }

    // Param is passed by value, moved
    pub fn set_logs_uri(&mut self, v: ::std::string::String) {
        self.logs_uri = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_logs_uri(&mut self) -> &mut ::std::string::String {
        &mut self.logs_uri
    }

    // Take field
    pub fn take_logs_uri(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.logs_uri, ::std::string::String::new())
    }

    // .grafeas.v1beta1.provenance.Source source_provenance = 10;


    pub fn get_source_provenance(&self) -> &Source {
        self.source_provenance.as_ref().unwrap_or_else(|| Source::default_instance())
    }
    pub fn clear_source_provenance(&mut self) {
        self.source_provenance.clear();
    }

    pub fn has_source_provenance(&self) -> bool {
        self.source_provenance.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source_provenance(&mut self, v: Source) {
        self.source_provenance = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_source_provenance(&mut self) -> &mut Source {
        if self.source_provenance.is_none() {
            self.source_provenance.set_default();
        }
        self.source_provenance.as_mut().unwrap()
    }

    // Take field
    pub fn take_source_provenance(&mut self) -> Source {
        self.source_provenance.take().unwrap_or_else(|| Source::new())
    }

    // string trigger_id = 11;


    pub fn get_trigger_id(&self) -> &str {
        &self.trigger_id
    }
    pub fn clear_trigger_id(&mut self) {
        self.trigger_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_trigger_id(&mut self, v: ::std::string::String) {
        self.trigger_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_trigger_id(&mut self) -> &mut ::std::string::String {
        &mut self.trigger_id
    }

    // Take field
    pub fn take_trigger_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.trigger_id, ::std::string::String::new())
    }

    // repeated .grafeas.v1beta1.provenance.BuildProvenance.BuildOptionsEntry build_options = 12;


    pub fn get_build_options(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.build_options
    }
    pub fn clear_build_options(&mut self) {
        self.build_options.clear();
    }

    // Param is passed by value, moved
    pub fn set_build_options(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.build_options = v;
    }

    // Mutable pointer to the field.
    pub fn mut_build_options(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.build_options
    }

    // Take field
    pub fn take_build_options(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.build_options, ::std::collections::HashMap::new())
    }

    // string builder_version = 13;


    pub fn get_builder_version(&self) -> &str {
        &self.builder_version
    }
    pub fn clear_builder_version(&mut self) {
        self.builder_version.clear();
    }

    // Param is passed by value, moved
    pub fn set_builder_version(&mut self, v: ::std::string::String) {
        self.builder_version = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_builder_version(&mut self) -> &mut ::std::string::String {
        &mut self.builder_version
    }

    // Take field
    pub fn take_builder_version(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.builder_version, ::std::string::String::new())
    }
}

impl ::protobuf::Message for BuildProvenance {
    fn is_initialized(&self) -> bool {
        for v in &self.commands {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.built_artifacts {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.create_time {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.start_time {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.end_time {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.source_provenance {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.project_id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.commands)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.built_artifacts)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.create_time)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.start_time)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.end_time)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.creator)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.logs_uri)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.source_provenance)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.trigger_id)?;
                },
                12 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.build_options)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.builder_version)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.project_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.project_id);
        }
        for value in &self.commands {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.built_artifacts {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.create_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.start_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.end_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.creator.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.creator);
        }
        if !self.logs_uri.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.logs_uri);
        }
        if let Some(ref v) = self.source_provenance.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.trigger_id.is_empty() {
            my_size += ::protobuf::rt::string_size(11, &self.trigger_id);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(12, &self.build_options);
        if !self.builder_version.is_empty() {
            my_size += ::protobuf::rt::string_size(13, &self.builder_version);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.project_id.is_empty() {
            os.write_string(2, &self.project_id)?;
        }
        for v in &self.commands {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.built_artifacts {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.create_time.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.start_time.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.end_time.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.creator.is_empty() {
            os.write_string(8, &self.creator)?;
        }
        if !self.logs_uri.is_empty() {
            os.write_string(9, &self.logs_uri)?;
        }
        if let Some(ref v) = self.source_provenance.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.trigger_id.is_empty() {
            os.write_string(11, &self.trigger_id)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(12, &self.build_options, os)?;
        if !self.builder_version.is_empty() {
            os.write_string(13, &self.builder_version)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BuildProvenance {
        BuildProvenance::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "id",
                    |m: &BuildProvenance| { &m.id },
                    |m: &mut BuildProvenance| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "project_id",
                    |m: &BuildProvenance| { &m.project_id },
                    |m: &mut BuildProvenance| { &mut m.project_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Command>>(
                    "commands",
                    |m: &BuildProvenance| { &m.commands },
                    |m: &mut BuildProvenance| { &mut m.commands },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Artifact>>(
                    "built_artifacts",
                    |m: &BuildProvenance| { &m.built_artifacts },
                    |m: &mut BuildProvenance| { &mut m.built_artifacts },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                    "create_time",
                    |m: &BuildProvenance| { &m.create_time },
                    |m: &mut BuildProvenance| { &mut m.create_time },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                    "start_time",
                    |m: &BuildProvenance| { &m.start_time },
                    |m: &mut BuildProvenance| { &mut m.start_time },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                    "end_time",
                    |m: &BuildProvenance| { &m.end_time },
                    |m: &mut BuildProvenance| { &mut m.end_time },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "creator",
                    |m: &BuildProvenance| { &m.creator },
                    |m: &mut BuildProvenance| { &mut m.creator },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "logs_uri",
                    |m: &BuildProvenance| { &m.logs_uri },
                    |m: &mut BuildProvenance| { &mut m.logs_uri },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Source>>(
                    "source_provenance",
                    |m: &BuildProvenance| { &m.source_provenance },
                    |m: &mut BuildProvenance| { &mut m.source_provenance },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "trigger_id",
                    |m: &BuildProvenance| { &m.trigger_id },
                    |m: &mut BuildProvenance| { &mut m.trigger_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                    "build_options",
                    |m: &BuildProvenance| { &m.build_options },
                    |m: &mut BuildProvenance| { &mut m.build_options },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "builder_version",
                    |m: &BuildProvenance| { &m.builder_version },
                    |m: &mut BuildProvenance| { &mut m.builder_version },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<BuildProvenance>(
                    "BuildProvenance",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static BuildProvenance {
        static mut instance: ::protobuf::lazy::Lazy<BuildProvenance> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const BuildProvenance,
        };
        unsafe {
            instance.get(BuildProvenance::new)
        }
    }
}

impl ::protobuf::Clear for BuildProvenance {
    fn clear(&mut self) {
        self.id.clear();
        self.project_id.clear();
        self.commands.clear();
        self.built_artifacts.clear();
        self.create_time.clear();
        self.start_time.clear();
        self.end_time.clear();
        self.creator.clear();
        self.logs_uri.clear();
        self.source_provenance.clear();
        self.trigger_id.clear();
        self.build_options.clear();
        self.builder_version.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BuildProvenance {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BuildProvenance {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Source {
    // message fields
    pub artifact_storage_source_uri: ::std::string::String,
    pub file_hashes: ::std::collections::HashMap<::std::string::String, FileHashes>,
    pub context: ::protobuf::SingularPtrField<super::source::SourceContext>,
    pub additional_contexts: ::protobuf::RepeatedField<super::source::SourceContext>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Source {
    fn default() -> &'a Source {
        <Source as ::protobuf::Message>::default_instance()
    }
}

impl Source {
    pub fn new() -> Source {
        ::std::default::Default::default()
    }

    // string artifact_storage_source_uri = 1;


    pub fn get_artifact_storage_source_uri(&self) -> &str {
        &self.artifact_storage_source_uri
    }
    pub fn clear_artifact_storage_source_uri(&mut self) {
        self.artifact_storage_source_uri.clear();
    }

    // Param is passed by value, moved
    pub fn set_artifact_storage_source_uri(&mut self, v: ::std::string::String) {
        self.artifact_storage_source_uri = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_artifact_storage_source_uri(&mut self) -> &mut ::std::string::String {
        &mut self.artifact_storage_source_uri
    }

    // Take field
    pub fn take_artifact_storage_source_uri(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.artifact_storage_source_uri, ::std::string::String::new())
    }

    // repeated .grafeas.v1beta1.provenance.Source.FileHashesEntry file_hashes = 2;


    pub fn get_file_hashes(&self) -> &::std::collections::HashMap<::std::string::String, FileHashes> {
        &self.file_hashes
    }
    pub fn clear_file_hashes(&mut self) {
        self.file_hashes.clear();
    }

    // Param is passed by value, moved
    pub fn set_file_hashes(&mut self, v: ::std::collections::HashMap<::std::string::String, FileHashes>) {
        self.file_hashes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_file_hashes(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, FileHashes> {
        &mut self.file_hashes
    }

    // Take field
    pub fn take_file_hashes(&mut self) -> ::std::collections::HashMap<::std::string::String, FileHashes> {
        ::std::mem::replace(&mut self.file_hashes, ::std::collections::HashMap::new())
    }

    // .grafeas.v1beta1.source.SourceContext context = 3;


    pub fn get_context(&self) -> &super::source::SourceContext {
        self.context.as_ref().unwrap_or_else(|| super::source::SourceContext::default_instance())
    }
    pub fn clear_context(&mut self) {
        self.context.clear();
    }

    pub fn has_context(&self) -> bool {
        self.context.is_some()
    }

    // Param is passed by value, moved
    pub fn set_context(&mut self, v: super::source::SourceContext) {
        self.context = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_context(&mut self) -> &mut super::source::SourceContext {
        if self.context.is_none() {
            self.context.set_default();
        }
        self.context.as_mut().unwrap()
    }

    // Take field
    pub fn take_context(&mut self) -> super::source::SourceContext {
        self.context.take().unwrap_or_else(|| super::source::SourceContext::new())
    }

    // repeated .grafeas.v1beta1.source.SourceContext additional_contexts = 4;


    pub fn get_additional_contexts(&self) -> &[super::source::SourceContext] {
        &self.additional_contexts
    }
    pub fn clear_additional_contexts(&mut self) {
        self.additional_contexts.clear();
    }

    // Param is passed by value, moved
    pub fn set_additional_contexts(&mut self, v: ::protobuf::RepeatedField<super::source::SourceContext>) {
        self.additional_contexts = v;
    }

    // Mutable pointer to the field.
    pub fn mut_additional_contexts(&mut self) -> &mut ::protobuf::RepeatedField<super::source::SourceContext> {
        &mut self.additional_contexts
    }

    // Take field
    pub fn take_additional_contexts(&mut self) -> ::protobuf::RepeatedField<super::source::SourceContext> {
        ::std::mem::replace(&mut self.additional_contexts, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Source {
    fn is_initialized(&self) -> bool {
        for v in &self.context {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.additional_contexts {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.artifact_storage_source_uri)?;
                },
                2 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<FileHashes>>(wire_type, is, &mut self.file_hashes)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.context)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.additional_contexts)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.artifact_storage_source_uri.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.artifact_storage_source_uri);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<FileHashes>>(2, &self.file_hashes);
        if let Some(ref v) = self.context.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.additional_contexts {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.artifact_storage_source_uri.is_empty() {
            os.write_string(1, &self.artifact_storage_source_uri)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<FileHashes>>(2, &self.file_hashes, os)?;
        if let Some(ref v) = self.context.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.additional_contexts {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Source {
        Source::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "artifact_storage_source_uri",
                    |m: &Source| { &m.artifact_storage_source_uri },
                    |m: &mut Source| { &mut m.artifact_storage_source_uri },
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<FileHashes>>(
                    "file_hashes",
                    |m: &Source| { &m.file_hashes },
                    |m: &mut Source| { &mut m.file_hashes },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::source::SourceContext>>(
                    "context",
                    |m: &Source| { &m.context },
                    |m: &mut Source| { &mut m.context },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::source::SourceContext>>(
                    "additional_contexts",
                    |m: &Source| { &m.additional_contexts },
                    |m: &mut Source| { &mut m.additional_contexts },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Source>(
                    "Source",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Source {
        static mut instance: ::protobuf::lazy::Lazy<Source> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Source,
        };
        unsafe {
            instance.get(Source::new)
        }
    }
}

impl ::protobuf::Clear for Source {
    fn clear(&mut self) {
        self.artifact_storage_source_uri.clear();
        self.file_hashes.clear();
        self.context.clear();
        self.additional_contexts.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Source {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Source {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FileHashes {
    // message fields
    pub file_hash: ::protobuf::RepeatedField<Hash>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FileHashes {
    fn default() -> &'a FileHashes {
        <FileHashes as ::protobuf::Message>::default_instance()
    }
}

impl FileHashes {
    pub fn new() -> FileHashes {
        ::std::default::Default::default()
    }

    // repeated .grafeas.v1beta1.provenance.Hash file_hash = 1;


    pub fn get_file_hash(&self) -> &[Hash] {
        &self.file_hash
    }
    pub fn clear_file_hash(&mut self) {
        self.file_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_file_hash(&mut self, v: ::protobuf::RepeatedField<Hash>) {
        self.file_hash = v;
    }

    // Mutable pointer to the field.
    pub fn mut_file_hash(&mut self) -> &mut ::protobuf::RepeatedField<Hash> {
        &mut self.file_hash
    }

    // Take field
    pub fn take_file_hash(&mut self) -> ::protobuf::RepeatedField<Hash> {
        ::std::mem::replace(&mut self.file_hash, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for FileHashes {
    fn is_initialized(&self) -> bool {
        for v in &self.file_hash {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.file_hash)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.file_hash {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.file_hash {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FileHashes {
        FileHashes::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Hash>>(
                    "file_hash",
                    |m: &FileHashes| { &m.file_hash },
                    |m: &mut FileHashes| { &mut m.file_hash },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<FileHashes>(
                    "FileHashes",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static FileHashes {
        static mut instance: ::protobuf::lazy::Lazy<FileHashes> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const FileHashes,
        };
        unsafe {
            instance.get(FileHashes::new)
        }
    }
}

impl ::protobuf::Clear for FileHashes {
    fn clear(&mut self) {
        self.file_hash.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FileHashes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FileHashes {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Hash {
    // message fields
    pub field_type: Hash_HashType,
    pub value: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Hash {
    fn default() -> &'a Hash {
        <Hash as ::protobuf::Message>::default_instance()
    }
}

impl Hash {
    pub fn new() -> Hash {
        ::std::default::Default::default()
    }

    // .grafeas.v1beta1.provenance.Hash.HashType type = 1;


    pub fn get_field_type(&self) -> Hash_HashType {
        self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = Hash_HashType::HASH_TYPE_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: Hash_HashType) {
        self.field_type = v;
    }

    // bytes value = 2;


    pub fn get_value(&self) -> &[u8] {
        &self.value
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::vec::Vec<u8>) {
        self.value = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.value
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.value, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for Hash {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.field_type != Hash_HashType::HASH_TYPE_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(1, self.field_type);
        }
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.value);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.field_type != Hash_HashType::HASH_TYPE_UNSPECIFIED {
            os.write_enum(1, self.field_type.value())?;
        }
        if !self.value.is_empty() {
            os.write_bytes(2, &self.value)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Hash {
        Hash::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Hash_HashType>>(
                    "type",
                    |m: &Hash| { &m.field_type },
                    |m: &mut Hash| { &mut m.field_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "value",
                    |m: &Hash| { &m.value },
                    |m: &mut Hash| { &mut m.value },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Hash>(
                    "Hash",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Hash {
        static mut instance: ::protobuf::lazy::Lazy<Hash> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Hash,
        };
        unsafe {
            instance.get(Hash::new)
        }
    }
}

impl ::protobuf::Clear for Hash {
    fn clear(&mut self) {
        self.field_type = Hash_HashType::HASH_TYPE_UNSPECIFIED;
        self.value.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Hash {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Hash {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Hash_HashType {
    HASH_TYPE_UNSPECIFIED = 0,
    SHA256 = 1,
}

impl ::protobuf::ProtobufEnum for Hash_HashType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Hash_HashType> {
        match value {
            0 => ::std::option::Option::Some(Hash_HashType::HASH_TYPE_UNSPECIFIED),
            1 => ::std::option::Option::Some(Hash_HashType::SHA256),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Hash_HashType] = &[
            Hash_HashType::HASH_TYPE_UNSPECIFIED,
            Hash_HashType::SHA256,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("Hash_HashType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for Hash_HashType {
}

impl ::std::default::Default for Hash_HashType {
    fn default() -> Self {
        Hash_HashType::HASH_TYPE_UNSPECIFIED
    }
}

impl ::protobuf::reflect::ProtobufValue for Hash_HashType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Command {
    // message fields
    pub name: ::std::string::String,
    pub env: ::protobuf::RepeatedField<::std::string::String>,
    pub args: ::protobuf::RepeatedField<::std::string::String>,
    pub dir: ::std::string::String,
    pub id: ::std::string::String,
    pub wait_for: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Command {
    fn default() -> &'a Command {
        <Command as ::protobuf::Message>::default_instance()
    }
}

impl Command {
    pub fn new() -> Command {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // repeated string env = 2;


    pub fn get_env(&self) -> &[::std::string::String] {
        &self.env
    }
    pub fn clear_env(&mut self) {
        self.env.clear();
    }

    // Param is passed by value, moved
    pub fn set_env(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.env = v;
    }

    // Mutable pointer to the field.
    pub fn mut_env(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.env
    }

    // Take field
    pub fn take_env(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.env, ::protobuf::RepeatedField::new())
    }

    // repeated string args = 3;


    pub fn get_args(&self) -> &[::std::string::String] {
        &self.args
    }
    pub fn clear_args(&mut self) {
        self.args.clear();
    }

    // Param is passed by value, moved
    pub fn set_args(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.args = v;
    }

    // Mutable pointer to the field.
    pub fn mut_args(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.args
    }

    // Take field
    pub fn take_args(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.args, ::protobuf::RepeatedField::new())
    }

    // string dir = 4;


    pub fn get_dir(&self) -> &str {
        &self.dir
    }
    pub fn clear_dir(&mut self) {
        self.dir.clear();
    }

    // Param is passed by value, moved
    pub fn set_dir(&mut self, v: ::std::string::String) {
        self.dir = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dir(&mut self) -> &mut ::std::string::String {
        &mut self.dir
    }

    // Take field
    pub fn take_dir(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.dir, ::std::string::String::new())
    }

    // string id = 5;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // repeated string wait_for = 6;


    pub fn get_wait_for(&self) -> &[::std::string::String] {
        &self.wait_for
    }
    pub fn clear_wait_for(&mut self) {
        self.wait_for.clear();
    }

    // Param is passed by value, moved
    pub fn set_wait_for(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.wait_for = v;
    }

    // Mutable pointer to the field.
    pub fn mut_wait_for(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.wait_for
    }

    // Take field
    pub fn take_wait_for(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.wait_for, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Command {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.env)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.args)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.dir)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.wait_for)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        for value in &self.env {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in &self.args {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        if !self.dir.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.dir);
        }
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.id);
        }
        for value in &self.wait_for {
            my_size += ::protobuf::rt::string_size(6, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        for v in &self.env {
            os.write_string(2, &v)?;
        };
        for v in &self.args {
            os.write_string(3, &v)?;
        };
        if !self.dir.is_empty() {
            os.write_string(4, &self.dir)?;
        }
        if !self.id.is_empty() {
            os.write_string(5, &self.id)?;
        }
        for v in &self.wait_for {
            os.write_string(6, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Command {
        Command::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &Command| { &m.name },
                    |m: &mut Command| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "env",
                    |m: &Command| { &m.env },
                    |m: &mut Command| { &mut m.env },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "args",
                    |m: &Command| { &m.args },
                    |m: &mut Command| { &mut m.args },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "dir",
                    |m: &Command| { &m.dir },
                    |m: &mut Command| { &mut m.dir },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "id",
                    |m: &Command| { &m.id },
                    |m: &mut Command| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "wait_for",
                    |m: &Command| { &m.wait_for },
                    |m: &mut Command| { &mut m.wait_for },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Command>(
                    "Command",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Command {
        static mut instance: ::protobuf::lazy::Lazy<Command> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Command,
        };
        unsafe {
            instance.get(Command::new)
        }
    }
}

impl ::protobuf::Clear for Command {
    fn clear(&mut self) {
        self.name.clear();
        self.env.clear();
        self.args.clear();
        self.dir.clear();
        self.id.clear();
        self.wait_for.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Command {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Command {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Artifact {
    // message fields
    pub checksum: ::std::string::String,
    pub id: ::std::string::String,
    pub names: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Artifact {
    fn default() -> &'a Artifact {
        <Artifact as ::protobuf::Message>::default_instance()
    }
}

impl Artifact {
    pub fn new() -> Artifact {
        ::std::default::Default::default()
    }

    // string checksum = 1;


    pub fn get_checksum(&self) -> &str {
        &self.checksum
    }
    pub fn clear_checksum(&mut self) {
        self.checksum.clear();
    }

    // Param is passed by value, moved
    pub fn set_checksum(&mut self, v: ::std::string::String) {
        self.checksum = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_checksum(&mut self) -> &mut ::std::string::String {
        &mut self.checksum
    }

    // Take field
    pub fn take_checksum(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.checksum, ::std::string::String::new())
    }

    // string id = 2;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // repeated string names = 3;


    pub fn get_names(&self) -> &[::std::string::String] {
        &self.names
    }
    pub fn clear_names(&mut self) {
        self.names.clear();
    }

    // Param is passed by value, moved
    pub fn set_names(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.names = v;
    }

    // Mutable pointer to the field.
    pub fn mut_names(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.names
    }

    // Take field
    pub fn take_names(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.names, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Artifact {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.checksum)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.names)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.checksum.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.checksum);
        }
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.id);
        }
        for value in &self.names {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.checksum.is_empty() {
            os.write_string(1, &self.checksum)?;
        }
        if !self.id.is_empty() {
            os.write_string(2, &self.id)?;
        }
        for v in &self.names {
            os.write_string(3, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Artifact {
        Artifact::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "checksum",
                    |m: &Artifact| { &m.checksum },
                    |m: &mut Artifact| { &mut m.checksum },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "id",
                    |m: &Artifact| { &m.id },
                    |m: &mut Artifact| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "names",
                    |m: &Artifact| { &m.names },
                    |m: &mut Artifact| { &mut m.names },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Artifact>(
                    "Artifact",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Artifact {
        static mut instance: ::protobuf::lazy::Lazy<Artifact> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Artifact,
        };
        unsafe {
            instance.get(Artifact::new)
        }
    }
}

impl ::protobuf::Clear for Artifact {
    fn clear(&mut self) {
        self.checksum.clear();
        self.id.clear();
        self.names.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Artifact {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Artifact {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x1eproto/v1beta1/provenance.proto\x12\x1agrafeas.v1beta1.provenance\
    \x1a\x1fgoogle/protobuf/timestamp.proto\x1a\x1aproto/v1beta1/source.prot\
    o\"\xf2\x05\n\x0fBuildProvenance\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02\
    id\x12\x1d\n\nproject_id\x18\x02\x20\x01(\tR\tprojectId\x12?\n\x08comman\
    ds\x18\x03\x20\x03(\x0b2#.grafeas.v1beta1.provenance.CommandR\x08command\
    s\x12M\n\x0fbuilt_artifacts\x18\x04\x20\x03(\x0b2$.grafeas.v1beta1.prove\
    nance.ArtifactR\x0ebuiltArtifacts\x12;\n\x0bcreate_time\x18\x05\x20\x01(\
    \x0b2\x1a.google.protobuf.TimestampR\ncreateTime\x129\n\nstart_time\x18\
    \x06\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\tstartTime\x125\n\x08e\
    nd_time\x18\x07\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\x07endTime\
    \x12\x18\n\x07creator\x18\x08\x20\x01(\tR\x07creator\x12\x19\n\x08logs_u\
    ri\x18\t\x20\x01(\tR\x07logsUri\x12O\n\x11source_provenance\x18\n\x20\
    \x01(\x0b2\".grafeas.v1beta1.provenance.SourceR\x10sourceProvenance\x12\
    \x1d\n\ntrigger_id\x18\x0b\x20\x01(\tR\ttriggerId\x12b\n\rbuild_options\
    \x18\x0c\x20\x03(\x0b2=.grafeas.v1beta1.provenance.BuildProvenance.Build\
    OptionsEntryR\x0cbuildOptions\x12'\n\x0fbuilder_version\x18\r\x20\x01(\t\
    R\x0ebuilderVersion\x1a?\n\x11BuildOptionsEntry\x12\x10\n\x03key\x18\x01\
    \x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x02\
    8\x01\"\x9c\x03\n\x06Source\x12=\n\x1bartifact_storage_source_uri\x18\
    \x01\x20\x01(\tR\x18artifactStorageSourceUri\x12S\n\x0bfile_hashes\x18\
    \x02\x20\x03(\x0b22.grafeas.v1beta1.provenance.Source.FileHashesEntryR\n\
    fileHashes\x12?\n\x07context\x18\x03\x20\x01(\x0b2%.grafeas.v1beta1.sour\
    ce.SourceContextR\x07context\x12V\n\x13additional_contexts\x18\x04\x20\
    \x03(\x0b2%.grafeas.v1beta1.source.SourceContextR\x12additionalContexts\
    \x1ae\n\x0fFileHashesEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\
    \x12<\n\x05value\x18\x02\x20\x01(\x0b2&.grafeas.v1beta1.provenance.FileH\
    ashesR\x05value:\x028\x01\"K\n\nFileHashes\x12=\n\tfile_hash\x18\x01\x20\
    \x03(\x0b2\x20.grafeas.v1beta1.provenance.HashR\x08fileHash\"\x8e\x01\n\
    \x04Hash\x12=\n\x04type\x18\x01\x20\x01(\x0e2).grafeas.v1beta1.provenanc\
    e.Hash.HashTypeR\x04type\x12\x14\n\x05value\x18\x02\x20\x01(\x0cR\x05val\
    ue\"1\n\x08HashType\x12\x19\n\x15HASH_TYPE_UNSPECIFIED\x10\0\x12\n\n\x06\
    SHA256\x10\x01\"\x80\x01\n\x07Command\x12\x12\n\x04name\x18\x01\x20\x01(\
    \tR\x04name\x12\x10\n\x03env\x18\x02\x20\x03(\tR\x03env\x12\x12\n\x04arg\
    s\x18\x03\x20\x03(\tR\x04args\x12\x10\n\x03dir\x18\x04\x20\x01(\tR\x03di\
    r\x12\x0e\n\x02id\x18\x05\x20\x01(\tR\x02id\x12\x19\n\x08wait_for\x18\
    \x06\x20\x03(\tR\x07waitFor\"L\n\x08Artifact\x12\x1a\n\x08checksum\x18\
    \x01\x20\x01(\tR\x08checksum\x12\x0e\n\x02id\x18\x02\x20\x01(\tR\x02id\
    \x12\x14\n\x05names\x18\x03\x20\x03(\tR\x05namesBe\n\x1dio.grafeas.v1bet\
    a1.provenanceP\x01Z<github.com/grafeas/grafeas/proto/v1beta1/provenance_\
    go_proto\xa2\x02\x03GRAJ\xad2\n\x07\x12\x05\x0e\0\xa3\x01\x01\n\xda\x04\
    \n\x01\x0c\x12\x03\x0e\0\x122\xcf\x04\x20Copyright\x202018\x20The\x20Gra\
    feas\x20Authors.\x20All\x20rights\x20reserved.\n\n\x20Licensed\x20under\
    \x20the\x20Apache\x20License,\x20Version\x202.0\x20(the\x20\"License\");\
    \n\x20you\x20may\x20not\x20use\x20this\x20file\x20except\x20in\x20compli\
    ance\x20with\x20the\x20License.\n\x20You\x20may\x20obtain\x20a\x20copy\
    \x20of\x20the\x20License\x20at\n\n\x20\x20\x20\x20http://www.apache.org/\
    licenses/LICENSE-2.0\n\n\x20Unless\x20required\x20by\x20applicable\x20la\
    w\x20or\x20agreed\x20to\x20in\x20writing,\x20software\n\x20distributed\
    \x20under\x20the\x20License\x20is\x20distributed\x20on\x20an\x20\"AS\x20\
    IS\"\x20BASIS,\n\x20WITHOUT\x20WARRANTIES\x20OR\x20CONDITIONS\x20OF\x20A\
    NY\x20KIND,\x20either\x20express\x20or\x20implied.\n\x20See\x20the\x20Li\
    cense\x20for\x20the\x20specific\x20language\x20governing\x20permissions\
    \x20and\n\x20limitations\x20under\x20the\x20License.\n\n\x08\n\x01\x02\
    \x12\x03\x10\0#\n\x08\n\x01\x08\x12\x03\x12\0S\n\t\n\x02\x08\x0b\x12\x03\
    \x12\0S\n\x08\n\x01\x08\x12\x03\x13\0\"\n\t\n\x02\x08\n\x12\x03\x13\0\"\
    \n\x08\n\x01\x08\x12\x03\x14\06\n\t\n\x02\x08\x01\x12\x03\x14\06\n\x08\n\
    \x01\x08\x12\x03\x15\0!\n\t\n\x02\x08$\x12\x03\x15\0!\n\t\n\x02\x03\0\
    \x12\x03\x17\0)\n\t\n\x02\x03\x01\x12\x03\x18\0$\n\x8b\x01\n\x02\x04\0\
    \x12\x04\x1c\0H\x01\x1a\x7f\x20Provenance\x20of\x20a\x20build.\x20Contai\
    ns\x20all\x20information\x20needed\x20to\x20verify\x20the\x20full\n\x20d\
    etails\x20about\x20the\x20build\x20from\x20source\x20to\x20completion.\n\
    \n\n\n\x03\x04\0\x01\x12\x03\x1c\x08\x17\n8\n\x04\x04\0\x02\0\x12\x03\
    \x1e\x02\x10\x1a+\x20Required.\x20Unique\x20identifier\x20of\x20the\x20b\
    uild.\n\n\r\n\x05\x04\0\x02\0\x04\x12\x04\x1e\x02\x1c\x19\n\x0c\n\x05\
    \x04\0\x02\0\x05\x12\x03\x1e\x02\x08\n\x0c\n\x05\x04\0\x02\0\x01\x12\x03\
    \x1e\t\x0b\n\x0c\n\x05\x04\0\x02\0\x03\x12\x03\x1e\x0e\x0f\n!\n\x04\x04\
    \0\x02\x01\x12\x03!\x02\x18\x1a\x14\x20ID\x20of\x20the\x20project.\n\n\r\
    \n\x05\x04\0\x02\x01\x04\x12\x04!\x02\x1e\x10\n\x0c\n\x05\x04\0\x02\x01\
    \x05\x12\x03!\x02\x08\n\x0c\n\x05\x04\0\x02\x01\x01\x12\x03!\t\x13\n\x0c\
    \n\x05\x04\0\x02\x01\x03\x12\x03!\x16\x17\n/\n\x04\x04\0\x02\x02\x12\x03\
    $\x02\x20\x1a\"\x20Commands\x20requested\x20by\x20the\x20build.\n\n\x0c\
    \n\x05\x04\0\x02\x02\x04\x12\x03$\x02\n\n\x0c\n\x05\x04\0\x02\x02\x06\
    \x12\x03$\x0b\x12\n\x0c\n\x05\x04\0\x02\x02\x01\x12\x03$\x13\x1b\n\x0c\n\
    \x05\x04\0\x02\x02\x03\x12\x03$\x1e\x1f\n#\n\x04\x04\0\x02\x03\x12\x03'\
    \x02(\x1a\x16\x20Output\x20of\x20the\x20build.\n\n\x0c\n\x05\x04\0\x02\
    \x03\x04\x12\x03'\x02\n\n\x0c\n\x05\x04\0\x02\x03\x06\x12\x03'\x0b\x13\n\
    \x0c\n\x05\x04\0\x02\x03\x01\x12\x03'\x14#\n\x0c\n\x05\x04\0\x02\x03\x03\
    \x12\x03'&'\n3\n\x04\x04\0\x02\x04\x12\x03*\x02,\x1a&\x20Time\x20at\x20w\
    hich\x20the\x20build\x20was\x20created.\n\n\r\n\x05\x04\0\x02\x04\x04\
    \x12\x04*\x02'(\n\x0c\n\x05\x04\0\x02\x04\x06\x12\x03*\x02\x1b\n\x0c\n\
    \x05\x04\0\x02\x04\x01\x12\x03*\x1c'\n\x0c\n\x05\x04\0\x02\x04\x03\x12\
    \x03**+\n@\n\x04\x04\0\x02\x05\x12\x03-\x02+\x1a3\x20Time\x20at\x20which\
    \x20execution\x20of\x20the\x20build\x20was\x20started.\n\n\r\n\x05\x04\0\
    \x02\x05\x04\x12\x04-\x02*,\n\x0c\n\x05\x04\0\x02\x05\x06\x12\x03-\x02\
    \x1b\n\x0c\n\x05\x04\0\x02\x05\x01\x12\x03-\x1c&\n\x0c\n\x05\x04\0\x02\
    \x05\x03\x12\x03-)*\nA\n\x04\x04\0\x02\x06\x12\x030\x02)\x1a4\x20Time\
    \x20at\x20which\x20execution\x20of\x20the\x20build\x20was\x20finished.\n\
    \n\r\n\x05\x04\0\x02\x06\x04\x12\x040\x02-+\n\x0c\n\x05\x04\0\x02\x06\
    \x06\x12\x030\x02\x1b\n\x0c\n\x05\x04\0\x02\x06\x01\x12\x030\x1c$\n\x0c\
    \n\x05\x04\0\x02\x06\x03\x12\x030'(\n\xd7\x01\n\x04\x04\0\x02\x07\x12\
    \x035\x02\x15\x1a\xc9\x01\x20E-mail\x20address\x20of\x20the\x20user\x20w\
    ho\x20initiated\x20this\x20build.\x20Note\x20that\x20this\x20was\x20the\
    \n\x20user's\x20e-mail\x20address\x20at\x20the\x20time\x20the\x20build\
    \x20was\x20initiated;\x20this\x20address\x20may\n\x20not\x20represent\
    \x20the\x20same\x20end-user\x20for\x20all\x20time.\n\n\r\n\x05\x04\0\x02\
    \x07\x04\x12\x045\x020)\n\x0c\n\x05\x04\0\x02\x07\x05\x12\x035\x02\x08\n\
    \x0c\n\x05\x04\0\x02\x07\x01\x12\x035\t\x10\n\x0c\n\x05\x04\0\x02\x07\
    \x03\x12\x035\x13\x14\nC\n\x04\x04\0\x02\x08\x12\x038\x02\x16\x1a6\x20UR\
    I\x20where\x20any\x20logs\x20for\x20this\x20provenance\x20were\x20writte\
    n.\n\n\r\n\x05\x04\0\x02\x08\x04\x12\x048\x025\x15\n\x0c\n\x05\x04\0\x02\
    \x08\x05\x12\x038\x02\x08\n\x0c\n\x05\x04\0\x02\x08\x01\x12\x038\t\x11\n\
    \x0c\n\x05\x04\0\x02\x08\x03\x12\x038\x14\x15\n8\n\x04\x04\0\x02\t\x12\
    \x03;\x02\x20\x1a+\x20Details\x20of\x20the\x20Source\x20input\x20to\x20t\
    he\x20build.\n\n\r\n\x05\x04\0\x02\t\x04\x12\x04;\x028\x16\n\x0c\n\x05\
    \x04\0\x02\t\x06\x12\x03;\x02\x08\n\x0c\n\x05\x04\0\x02\t\x01\x12\x03;\t\
    \x1a\n\x0c\n\x05\x04\0\x02\t\x03\x12\x03;\x1d\x1f\nY\n\x04\x04\0\x02\n\
    \x12\x03>\x02\x19\x1aL\x20Trigger\x20identifier\x20if\x20the\x20build\
    \x20was\x20triggered\x20automatically;\x20empty\x20if\x20not.\n\n\r\n\
    \x05\x04\0\x02\n\x04\x12\x04>\x02;\x20\n\x0c\n\x05\x04\0\x02\n\x05\x12\
    \x03>\x02\x08\n\x0c\n\x05\x04\0\x02\n\x01\x12\x03>\t\x13\n\x0c\n\x05\x04\
    \0\x02\n\x03\x12\x03>\x16\x18\n\x91\x01\n\x04\x04\0\x02\x0b\x12\x03B\x02\
    )\x1a\x83\x01\x20Special\x20options\x20applied\x20to\x20this\x20build.\
    \x20This\x20is\x20a\x20catch-all\x20field\x20where\n\x20build\x20provide\
    rs\x20can\x20enter\x20any\x20desired\x20additional\x20details.\n\n\r\n\
    \x05\x04\0\x02\x0b\x04\x12\x04B\x02>\x19\n\x0c\n\x05\x04\0\x02\x0b\x06\
    \x12\x03B\x02\x15\n\x0c\n\x05\x04\0\x02\x0b\x01\x12\x03B\x16#\n\x0c\n\
    \x05\x04\0\x02\x0b\x03\x12\x03B&(\nQ\n\x04\x04\0\x02\x0c\x12\x03E\x02\
    \x1e\x1aD\x20Version\x20string\x20of\x20the\x20builder\x20at\x20the\x20t\
    ime\x20this\x20build\x20was\x20executed.\n\n\r\n\x05\x04\0\x02\x0c\x04\
    \x12\x04E\x02B)\n\x0c\n\x05\x04\0\x02\x0c\x05\x12\x03E\x02\x08\n\x0c\n\
    \x05\x04\0\x02\x0c\x01\x12\x03E\t\x18\n\x0c\n\x05\x04\0\x02\x0c\x03\x12\
    \x03E\x1b\x1d\nM\n\x02\x04\x01\x12\x04K\0b\x01\x1aA\x20Source\x20describ\
    es\x20the\x20location\x20of\x20the\x20source\x20used\x20for\x20the\x20bu\
    ild.\n\n\n\n\x03\x04\x01\x01\x12\x03K\x08\x0e\n^\n\x04\x04\x01\x02\0\x12\
    \x03N\x02)\x1aQ\x20If\x20provided,\x20the\x20input\x20binary\x20artifact\
    s\x20for\x20the\x20build\x20came\x20from\x20this\n\x20location.\n\n\r\n\
    \x05\x04\x01\x02\0\x04\x12\x04N\x02K\x10\n\x0c\n\x05\x04\x01\x02\0\x05\
    \x12\x03N\x02\x08\n\x0c\n\x05\x04\x01\x02\0\x01\x12\x03N\t$\n\x0c\n\x05\
    \x04\x01\x02\0\x03\x12\x03N'(\n\x8a\x03\n\x04\x04\x01\x02\x01\x12\x03X\
    \x02*\x1a\xfc\x02\x20Hash(es)\x20of\x20the\x20build\x20source,\x20which\
    \x20can\x20be\x20used\x20to\x20verify\x20that\x20the\x20original\n\x20so\
    urce\x20integrity\x20was\x20maintained\x20in\x20the\x20build.\n\n\x20The\
    \x20keys\x20to\x20this\x20map\x20are\x20file\x20paths\x20used\x20as\x20b\
    uild\x20source\x20and\x20the\x20values\n\x20contain\x20the\x20hash\x20va\
    lues\x20for\x20those\x20files.\n\n\x20If\x20the\x20build\x20source\x20ca\
    me\x20in\x20a\x20single\x20package\x20such\x20as\x20a\x20gzipped\x20tarf\
    ile\n\x20(.tar.gz),\x20the\x20FileHash\x20will\x20be\x20for\x20the\x20si\
    ngle\x20path\x20to\x20that\x20file.\n\n\r\n\x05\x04\x01\x02\x01\x04\x12\
    \x04X\x02N)\n\x0c\n\x05\x04\x01\x02\x01\x06\x12\x03X\x02\x19\n\x0c\n\x05\
    \x04\x01\x02\x01\x01\x12\x03X\x1a%\n\x0c\n\x05\x04\x01\x02\x01\x03\x12\
    \x03X()\nW\n\x04\x04\x01\x02\x02\x12\x03[\x023\x1aJ\x20If\x20provided,\
    \x20the\x20source\x20code\x20used\x20for\x20the\x20build\x20came\x20from\
    \x20this\x20location.\n\n\r\n\x05\x04\x01\x02\x02\x04\x12\x04[\x02X*\n\
    \x0c\n\x05\x04\x01\x02\x02\x06\x12\x03[\x02&\n\x0c\n\x05\x04\x01\x02\x02\
    \x01\x12\x03['.\n\x0c\n\x05\x04\x01\x02\x02\x03\x12\x03[12\n\xfe\x01\n\
    \x04\x04\x01\x02\x03\x12\x03a\x02H\x1a\xf0\x01\x20If\x20provided,\x20som\
    e\x20of\x20the\x20source\x20code\x20used\x20for\x20the\x20build\x20may\
    \x20be\x20found\x20in\n\x20these\x20locations,\x20in\x20the\x20case\x20w\
    here\x20the\x20source\x20repository\x20had\x20multiple\n\x20remotes\x20o\
    r\x20submodules.\x20This\x20list\x20will\x20not\x20include\x20the\x20con\
    text\x20specified\x20in\n\x20the\x20context\x20field.\n\n\x0c\n\x05\x04\
    \x01\x02\x03\x04\x12\x03a\x02\n\n\x0c\n\x05\x04\x01\x02\x03\x06\x12\x03a\
    \x0b/\n\x0c\n\x05\x04\x01\x02\x03\x01\x12\x03a0C\n\x0c\n\x05\x04\x01\x02\
    \x03\x03\x12\x03aFG\n\x90\x01\n\x02\x04\x02\x12\x04f\0i\x01\x1a\x83\x01\
    \x20Container\x20message\x20for\x20hashes\x20of\x20byte\x20content\x20of\
    \x20files,\x20used\x20in\x20source\n\x20messages\x20to\x20verify\x20inte\
    grity\x20of\x20source\x20input\x20to\x20the\x20build.\n\n\n\n\x03\x04\
    \x02\x01\x12\x03f\x08\x12\n3\n\x04\x04\x02\x02\0\x12\x03h\x02\x1e\x1a&\
    \x20Required.\x20Collection\x20of\x20file\x20hashes.\n\n\x0c\n\x05\x04\
    \x02\x02\0\x04\x12\x03h\x02\n\n\x0c\n\x05\x04\x02\x02\0\x06\x12\x03h\x0b\
    \x0f\n\x0c\n\x05\x04\x02\x02\0\x01\x12\x03h\x10\x19\n\x0c\n\x05\x04\x02\
    \x02\0\x03\x12\x03h\x1c\x1d\n0\n\x02\x04\x03\x12\x04l\0y\x01\x1a$\x20Con\
    tainer\x20message\x20for\x20hash\x20values.\n\n\n\n\x03\x04\x03\x01\x12\
    \x03l\x08\x0c\n-\n\x04\x04\x03\x04\0\x12\x04n\x02s\x03\x1a\x1f\x20Specif\
    ies\x20the\x20hash\x20algorithm.\n\n\x0c\n\x05\x04\x03\x04\0\x01\x12\x03\
    n\x07\x0f\n\x19\n\x06\x04\x03\x04\0\x02\0\x12\x03p\x04\x1e\x1a\n\x20Unkn\
    own.\n\n\x0e\n\x07\x04\x03\x04\0\x02\0\x01\x12\x03p\x04\x19\n\x0e\n\x07\
    \x04\x03\x04\0\x02\0\x02\x12\x03p\x1c\x1d\n\x20\n\x06\x04\x03\x04\0\x02\
    \x01\x12\x03r\x04\x0f\x1a\x11\x20A\x20SHA-256\x20hash.\n\n\x0e\n\x07\x04\
    \x03\x04\0\x02\x01\x01\x12\x03r\x04\n\n\x0e\n\x07\x04\x03\x04\0\x02\x01\
    \x02\x12\x03r\r\x0e\n=\n\x04\x04\x03\x02\0\x12\x03v\x02\x14\x1a0\x20Requ\
    ired.\x20The\x20type\x20of\x20hash\x20that\x20was\x20performed.\n\n\r\n\
    \x05\x04\x03\x02\0\x04\x12\x04v\x02s\x03\n\x0c\n\x05\x04\x03\x02\0\x06\
    \x12\x03v\x02\n\n\x0c\n\x05\x04\x03\x02\0\x01\x12\x03v\x0b\x0f\n\x0c\n\
    \x05\x04\x03\x02\0\x03\x12\x03v\x12\x13\n(\n\x04\x04\x03\x02\x01\x12\x03\
    x\x02\x12\x1a\x1b\x20Required.\x20The\x20hash\x20value.\n\n\r\n\x05\x04\
    \x03\x02\x01\x04\x12\x04x\x02v\x14\n\x0c\n\x05\x04\x03\x02\x01\x05\x12\
    \x03x\x02\x07\n\x0c\n\x05\x04\x03\x02\x01\x01\x12\x03x\x08\r\n\x0c\n\x05\
    \x04\x03\x02\x01\x03\x12\x03x\x10\x11\nP\n\x02\x04\x04\x12\x05|\0\x91\
    \x01\x01\x1aC\x20Command\x20describes\x20a\x20step\x20performed\x20as\
    \x20part\x20of\x20the\x20build\x20pipeline.\n\n\n\n\x03\x04\x04\x01\x12\
    \x03|\x08\x0f\n\xa5\x01\n\x04\x04\x04\x02\0\x12\x03\x7f\x02\x12\x1a\x97\
    \x01\x20Required.\x20Name\x20of\x20the\x20command,\x20as\x20presented\
    \x20on\x20the\x20command\x20line,\x20or\x20if\x20the\n\x20command\x20is\
    \x20packaged\x20as\x20a\x20Docker\x20container,\x20as\x20presented\x20to\
    \x20`docker\x20pull`.\n\n\r\n\x05\x04\x04\x02\0\x04\x12\x04\x7f\x02|\x11\
    \n\x0c\n\x05\x04\x04\x02\0\x05\x12\x03\x7f\x02\x08\n\x0c\n\x05\x04\x04\
    \x02\0\x01\x12\x03\x7f\t\r\n\x0c\n\x05\x04\x04\x02\0\x03\x12\x03\x7f\x10\
    \x11\nF\n\x04\x04\x04\x02\x01\x12\x04\x82\x01\x02\x1a\x1a8\x20Environmen\
    t\x20variables\x20set\x20before\x20running\x20this\x20command.\n\n\r\n\
    \x05\x04\x04\x02\x01\x04\x12\x04\x82\x01\x02\n\n\r\n\x05\x04\x04\x02\x01\
    \x05\x12\x04\x82\x01\x0b\x11\n\r\n\x05\x04\x04\x02\x01\x01\x12\x04\x82\
    \x01\x12\x15\n\r\n\x05\x04\x04\x02\x01\x03\x12\x04\x82\x01\x18\x19\nH\n\
    \x04\x04\x04\x02\x02\x12\x04\x85\x01\x02\x1b\x1a:\x20Command-line\x20arg\
    uments\x20used\x20when\x20executing\x20this\x20command.\n\n\r\n\x05\x04\
    \x04\x02\x02\x04\x12\x04\x85\x01\x02\n\n\r\n\x05\x04\x04\x02\x02\x05\x12\
    \x04\x85\x01\x0b\x11\n\r\n\x05\x04\x04\x02\x02\x01\x12\x04\x85\x01\x12\
    \x16\n\r\n\x05\x04\x04\x02\x02\x03\x12\x04\x85\x01\x19\x1a\nd\n\x04\x04\
    \x04\x02\x03\x12\x04\x89\x01\x02\x11\x1aV\x20Working\x20directory\x20(re\
    lative\x20to\x20project\x20source\x20root)\x20used\x20when\x20running\
    \x20this\n\x20command.\n\n\x0f\n\x05\x04\x04\x02\x03\x04\x12\x06\x89\x01\
    \x02\x85\x01\x1b\n\r\n\x05\x04\x04\x02\x03\x05\x12\x04\x89\x01\x02\x08\n\
    \r\n\x05\x04\x04\x02\x03\x01\x12\x04\x89\x01\t\x0c\n\r\n\x05\x04\x04\x02\
    \x03\x03\x12\x04\x89\x01\x0f\x10\ny\n\x04\x04\x04\x02\x04\x12\x04\x8d\
    \x01\x02\x10\x1ak\x20Optional\x20unique\x20identifier\x20for\x20this\x20\
    command,\x20used\x20in\x20wait_for\x20to\x20reference\n\x20this\x20comma\
    nd\x20as\x20a\x20dependency.\n\n\x0f\n\x05\x04\x04\x02\x04\x04\x12\x06\
    \x8d\x01\x02\x89\x01\x11\n\r\n\x05\x04\x04\x02\x04\x05\x12\x04\x8d\x01\
    \x02\x08\n\r\n\x05\x04\x04\x02\x04\x01\x12\x04\x8d\x01\t\x0b\n\r\n\x05\
    \x04\x04\x02\x04\x03\x12\x04\x8d\x01\x0e\x0f\nI\n\x04\x04\x04\x02\x05\
    \x12\x04\x90\x01\x02\x1f\x1a;\x20The\x20ID(s)\x20of\x20the\x20command(s)\
    \x20that\x20this\x20command\x20depends\x20on.\n\n\r\n\x05\x04\x04\x02\
    \x05\x04\x12\x04\x90\x01\x02\n\n\r\n\x05\x04\x04\x02\x05\x05\x12\x04\x90\
    \x01\x0b\x11\n\r\n\x05\x04\x04\x02\x05\x01\x12\x04\x90\x01\x12\x1a\n\r\n\
    \x05\x04\x04\x02\x05\x03\x12\x04\x90\x01\x1d\x1e\n3\n\x02\x04\x05\x12\
    \x06\x94\x01\0\xa3\x01\x01\x1a%\x20Artifact\x20describes\x20a\x20build\
    \x20product.\n\n\x0b\n\x03\x04\x05\x01\x12\x04\x94\x01\x08\x10\nb\n\x04\
    \x04\x05\x02\0\x12\x04\x97\x01\x02\x16\x1aT\x20Hash\x20or\x20checksum\
    \x20value\x20of\x20a\x20binary,\x20or\x20Docker\x20Registry\x202.0\x20di\
    gest\x20of\x20a\n\x20container.\n\n\x0f\n\x05\x04\x05\x02\0\x04\x12\x06\
    \x97\x01\x02\x94\x01\x12\n\r\n\x05\x04\x05\x02\0\x05\x12\x04\x97\x01\x02\
    \x08\n\r\n\x05\x04\x05\x02\0\x01\x12\x04\x97\x01\t\x11\n\r\n\x05\x04\x05\
    \x02\0\x03\x12\x04\x97\x01\x14\x15\n\x89\x01\n\x04\x04\x05\x02\x01\x12\
    \x04\x9b\x01\x02\x10\x1a{\x20Artifact\x20ID,\x20if\x20any;\x20for\x20con\
    tainer\x20images,\x20this\x20will\x20be\x20a\x20URL\x20by\x20digest\n\
    \x20like\x20`gcr.io/projectID/imagename@sha256:123456`.\n\n\x0f\n\x05\
    \x04\x05\x02\x01\x04\x12\x06\x9b\x01\x02\x97\x01\x16\n\r\n\x05\x04\x05\
    \x02\x01\x05\x12\x04\x9b\x01\x02\x08\n\r\n\x05\x04\x05\x02\x01\x01\x12\
    \x04\x9b\x01\t\x0b\n\r\n\x05\x04\x05\x02\x01\x03\x12\x04\x9b\x01\x0e\x0f\
    \n\xd0\x02\n\x04\x04\x05\x02\x02\x12\x04\xa2\x01\x02\x1c\x1a\xc1\x02\x20\
    Related\x20artifact\x20names.\x20This\x20may\x20be\x20the\x20path\x20to\
    \x20a\x20binary\x20or\x20jar\x20file,\x20or\x20in\n\x20the\x20case\x20of\
    \x20a\x20container\x20build,\x20the\x20name\x20used\x20to\x20push\x20the\
    \x20container\x20image\x20to\n\x20Google\x20Container\x20Registry,\x20as\
    \x20presented\x20to\x20`docker\x20push`.\x20Note\x20that\x20a\n\x20singl\
    e\x20Artifact\x20ID\x20can\x20have\x20multiple\x20names,\x20for\x20examp\
    le\x20if\x20two\x20tags\x20are\n\x20applied\x20to\x20one\x20image.\n\n\r\
    \n\x05\x04\x05\x02\x02\x04\x12\x04\xa2\x01\x02\n\n\r\n\x05\x04\x05\x02\
    \x02\x05\x12\x04\xa2\x01\x0b\x11\n\r\n\x05\x04\x05\x02\x02\x01\x12\x04\
    \xa2\x01\x12\x17\n\r\n\x05\x04\x05\x02\x02\x03\x12\x04\xa2\x01\x1a\x1bb\
    \x06proto3\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
