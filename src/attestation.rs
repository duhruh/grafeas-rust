// This file is generated by rust-protobuf 2.6.0. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

#[derive(PartialEq,Clone,Default)]
pub struct PgpSignedAttestation {
    // message fields
    pub signature: ::std::string::String,
    pub content_type: PgpSignedAttestation_ContentType,
    // message oneof groups
    pub key_id: ::std::option::Option<PgpSignedAttestation_oneof_key_id>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PgpSignedAttestation {
    fn default() -> &'a PgpSignedAttestation {
        <PgpSignedAttestation as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum PgpSignedAttestation_oneof_key_id {
    pgp_key_id(::std::string::String),
}

impl PgpSignedAttestation {
    pub fn new() -> PgpSignedAttestation {
        ::std::default::Default::default()
    }

    // string signature = 1;


    pub fn get_signature(&self) -> &str {
        &self.signature
    }
    pub fn clear_signature(&mut self) {
        self.signature.clear();
    }

    // Param is passed by value, moved
    pub fn set_signature(&mut self, v: ::std::string::String) {
        self.signature = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_signature(&mut self) -> &mut ::std::string::String {
        &mut self.signature
    }

    // Take field
    pub fn take_signature(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.signature, ::std::string::String::new())
    }

    // .grafeas.v1beta1.attestation.PgpSignedAttestation.ContentType content_type = 3;


    pub fn get_content_type(&self) -> PgpSignedAttestation_ContentType {
        self.content_type
    }
    pub fn clear_content_type(&mut self) {
        self.content_type = PgpSignedAttestation_ContentType::CONTENT_TYPE_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_content_type(&mut self, v: PgpSignedAttestation_ContentType) {
        self.content_type = v;
    }

    // string pgp_key_id = 2;


    pub fn get_pgp_key_id(&self) -> &str {
        match self.key_id {
            ::std::option::Option::Some(PgpSignedAttestation_oneof_key_id::pgp_key_id(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_pgp_key_id(&mut self) {
        self.key_id = ::std::option::Option::None;
    }

    pub fn has_pgp_key_id(&self) -> bool {
        match self.key_id {
            ::std::option::Option::Some(PgpSignedAttestation_oneof_key_id::pgp_key_id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_pgp_key_id(&mut self, v: ::std::string::String) {
        self.key_id = ::std::option::Option::Some(PgpSignedAttestation_oneof_key_id::pgp_key_id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_pgp_key_id(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(PgpSignedAttestation_oneof_key_id::pgp_key_id(_)) = self.key_id {
        } else {
            self.key_id = ::std::option::Option::Some(PgpSignedAttestation_oneof_key_id::pgp_key_id(::std::string::String::new()));
        }
        match self.key_id {
            ::std::option::Option::Some(PgpSignedAttestation_oneof_key_id::pgp_key_id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_pgp_key_id(&mut self) -> ::std::string::String {
        if self.has_pgp_key_id() {
            match self.key_id.take() {
                ::std::option::Option::Some(PgpSignedAttestation_oneof_key_id::pgp_key_id(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }
}

impl ::protobuf::Message for PgpSignedAttestation {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.signature)?;
                },
                3 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.content_type, 3, &mut self.unknown_fields)?
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.key_id = ::std::option::Option::Some(PgpSignedAttestation_oneof_key_id::pgp_key_id(is.read_string()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.signature.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.signature);
        }
        if self.content_type != PgpSignedAttestation_ContentType::CONTENT_TYPE_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(3, self.content_type);
        }
        if let ::std::option::Option::Some(ref v) = self.key_id {
            match v {
                &PgpSignedAttestation_oneof_key_id::pgp_key_id(ref v) => {
                    my_size += ::protobuf::rt::string_size(2, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.signature.is_empty() {
            os.write_string(1, &self.signature)?;
        }
        if self.content_type != PgpSignedAttestation_ContentType::CONTENT_TYPE_UNSPECIFIED {
            os.write_enum(3, self.content_type.value())?;
        }
        if let ::std::option::Option::Some(ref v) = self.key_id {
            match v {
                &PgpSignedAttestation_oneof_key_id::pgp_key_id(ref v) => {
                    os.write_string(2, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PgpSignedAttestation {
        PgpSignedAttestation::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "signature",
                    |m: &PgpSignedAttestation| { &m.signature },
                    |m: &mut PgpSignedAttestation| { &mut m.signature },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<PgpSignedAttestation_ContentType>>(
                    "content_type",
                    |m: &PgpSignedAttestation| { &m.content_type },
                    |m: &mut PgpSignedAttestation| { &mut m.content_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                    "pgp_key_id",
                    PgpSignedAttestation::has_pgp_key_id,
                    PgpSignedAttestation::get_pgp_key_id,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PgpSignedAttestation>(
                    "PgpSignedAttestation",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PgpSignedAttestation {
        static mut instance: ::protobuf::lazy::Lazy<PgpSignedAttestation> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PgpSignedAttestation,
        };
        unsafe {
            instance.get(PgpSignedAttestation::new)
        }
    }
}

impl ::protobuf::Clear for PgpSignedAttestation {
    fn clear(&mut self) {
        self.signature.clear();
        self.content_type = PgpSignedAttestation_ContentType::CONTENT_TYPE_UNSPECIFIED;
        self.key_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PgpSignedAttestation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PgpSignedAttestation {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum PgpSignedAttestation_ContentType {
    CONTENT_TYPE_UNSPECIFIED = 0,
    SIMPLE_SIGNING_JSON = 1,
}

impl ::protobuf::ProtobufEnum for PgpSignedAttestation_ContentType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<PgpSignedAttestation_ContentType> {
        match value {
            0 => ::std::option::Option::Some(PgpSignedAttestation_ContentType::CONTENT_TYPE_UNSPECIFIED),
            1 => ::std::option::Option::Some(PgpSignedAttestation_ContentType::SIMPLE_SIGNING_JSON),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [PgpSignedAttestation_ContentType] = &[
            PgpSignedAttestation_ContentType::CONTENT_TYPE_UNSPECIFIED,
            PgpSignedAttestation_ContentType::SIMPLE_SIGNING_JSON,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("PgpSignedAttestation_ContentType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for PgpSignedAttestation_ContentType {
}

impl ::std::default::Default for PgpSignedAttestation_ContentType {
    fn default() -> Self {
        PgpSignedAttestation_ContentType::CONTENT_TYPE_UNSPECIFIED
    }
}

impl ::protobuf::reflect::ProtobufValue for PgpSignedAttestation_ContentType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GenericSignedAttestation {
    // message fields
    pub content_type: GenericSignedAttestation_ContentType,
    pub serialized_payload: ::std::vec::Vec<u8>,
    pub signatures: ::protobuf::RepeatedField<super::common::Signature>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GenericSignedAttestation {
    fn default() -> &'a GenericSignedAttestation {
        <GenericSignedAttestation as ::protobuf::Message>::default_instance()
    }
}

impl GenericSignedAttestation {
    pub fn new() -> GenericSignedAttestation {
        ::std::default::Default::default()
    }

    // .grafeas.v1beta1.attestation.GenericSignedAttestation.ContentType content_type = 1;


    pub fn get_content_type(&self) -> GenericSignedAttestation_ContentType {
        self.content_type
    }
    pub fn clear_content_type(&mut self) {
        self.content_type = GenericSignedAttestation_ContentType::CONTENT_TYPE_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_content_type(&mut self, v: GenericSignedAttestation_ContentType) {
        self.content_type = v;
    }

    // bytes serialized_payload = 2;


    pub fn get_serialized_payload(&self) -> &[u8] {
        &self.serialized_payload
    }
    pub fn clear_serialized_payload(&mut self) {
        self.serialized_payload.clear();
    }

    // Param is passed by value, moved
    pub fn set_serialized_payload(&mut self, v: ::std::vec::Vec<u8>) {
        self.serialized_payload = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_serialized_payload(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.serialized_payload
    }

    // Take field
    pub fn take_serialized_payload(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.serialized_payload, ::std::vec::Vec::new())
    }

    // repeated .grafeas.v1beta1.Signature signatures = 3;


    pub fn get_signatures(&self) -> &[super::common::Signature] {
        &self.signatures
    }
    pub fn clear_signatures(&mut self) {
        self.signatures.clear();
    }

    // Param is passed by value, moved
    pub fn set_signatures(&mut self, v: ::protobuf::RepeatedField<super::common::Signature>) {
        self.signatures = v;
    }

    // Mutable pointer to the field.
    pub fn mut_signatures(&mut self) -> &mut ::protobuf::RepeatedField<super::common::Signature> {
        &mut self.signatures
    }

    // Take field
    pub fn take_signatures(&mut self) -> ::protobuf::RepeatedField<super::common::Signature> {
        ::std::mem::replace(&mut self.signatures, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for GenericSignedAttestation {
    fn is_initialized(&self) -> bool {
        for v in &self.signatures {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.content_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.serialized_payload)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.signatures)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.content_type != GenericSignedAttestation_ContentType::CONTENT_TYPE_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(1, self.content_type);
        }
        if !self.serialized_payload.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.serialized_payload);
        }
        for value in &self.signatures {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.content_type != GenericSignedAttestation_ContentType::CONTENT_TYPE_UNSPECIFIED {
            os.write_enum(1, self.content_type.value())?;
        }
        if !self.serialized_payload.is_empty() {
            os.write_bytes(2, &self.serialized_payload)?;
        }
        for v in &self.signatures {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GenericSignedAttestation {
        GenericSignedAttestation::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<GenericSignedAttestation_ContentType>>(
                    "content_type",
                    |m: &GenericSignedAttestation| { &m.content_type },
                    |m: &mut GenericSignedAttestation| { &mut m.content_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "serialized_payload",
                    |m: &GenericSignedAttestation| { &m.serialized_payload },
                    |m: &mut GenericSignedAttestation| { &mut m.serialized_payload },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::common::Signature>>(
                    "signatures",
                    |m: &GenericSignedAttestation| { &m.signatures },
                    |m: &mut GenericSignedAttestation| { &mut m.signatures },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GenericSignedAttestation>(
                    "GenericSignedAttestation",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GenericSignedAttestation {
        static mut instance: ::protobuf::lazy::Lazy<GenericSignedAttestation> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GenericSignedAttestation,
        };
        unsafe {
            instance.get(GenericSignedAttestation::new)
        }
    }
}

impl ::protobuf::Clear for GenericSignedAttestation {
    fn clear(&mut self) {
        self.content_type = GenericSignedAttestation_ContentType::CONTENT_TYPE_UNSPECIFIED;
        self.serialized_payload.clear();
        self.signatures.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GenericSignedAttestation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GenericSignedAttestation {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum GenericSignedAttestation_ContentType {
    CONTENT_TYPE_UNSPECIFIED = 0,
    SIMPLE_SIGNING_JSON = 1,
}

impl ::protobuf::ProtobufEnum for GenericSignedAttestation_ContentType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<GenericSignedAttestation_ContentType> {
        match value {
            0 => ::std::option::Option::Some(GenericSignedAttestation_ContentType::CONTENT_TYPE_UNSPECIFIED),
            1 => ::std::option::Option::Some(GenericSignedAttestation_ContentType::SIMPLE_SIGNING_JSON),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [GenericSignedAttestation_ContentType] = &[
            GenericSignedAttestation_ContentType::CONTENT_TYPE_UNSPECIFIED,
            GenericSignedAttestation_ContentType::SIMPLE_SIGNING_JSON,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("GenericSignedAttestation_ContentType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for GenericSignedAttestation_ContentType {
}

impl ::std::default::Default for GenericSignedAttestation_ContentType {
    fn default() -> Self {
        GenericSignedAttestation_ContentType::CONTENT_TYPE_UNSPECIFIED
    }
}

impl ::protobuf::reflect::ProtobufValue for GenericSignedAttestation_ContentType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Authority {
    // message fields
    pub hint: ::protobuf::SingularPtrField<Authority_Hint>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Authority {
    fn default() -> &'a Authority {
        <Authority as ::protobuf::Message>::default_instance()
    }
}

impl Authority {
    pub fn new() -> Authority {
        ::std::default::Default::default()
    }

    // .grafeas.v1beta1.attestation.Authority.Hint hint = 1;


    pub fn get_hint(&self) -> &Authority_Hint {
        self.hint.as_ref().unwrap_or_else(|| Authority_Hint::default_instance())
    }
    pub fn clear_hint(&mut self) {
        self.hint.clear();
    }

    pub fn has_hint(&self) -> bool {
        self.hint.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hint(&mut self, v: Authority_Hint) {
        self.hint = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hint(&mut self) -> &mut Authority_Hint {
        if self.hint.is_none() {
            self.hint.set_default();
        }
        self.hint.as_mut().unwrap()
    }

    // Take field
    pub fn take_hint(&mut self) -> Authority_Hint {
        self.hint.take().unwrap_or_else(|| Authority_Hint::new())
    }
}

impl ::protobuf::Message for Authority {
    fn is_initialized(&self) -> bool {
        for v in &self.hint {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.hint)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.hint.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.hint.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Authority {
        Authority::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Authority_Hint>>(
                    "hint",
                    |m: &Authority| { &m.hint },
                    |m: &mut Authority| { &mut m.hint },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Authority>(
                    "Authority",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Authority {
        static mut instance: ::protobuf::lazy::Lazy<Authority> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Authority,
        };
        unsafe {
            instance.get(Authority::new)
        }
    }
}

impl ::protobuf::Clear for Authority {
    fn clear(&mut self) {
        self.hint.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Authority {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Authority {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Authority_Hint {
    // message fields
    pub human_readable_name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Authority_Hint {
    fn default() -> &'a Authority_Hint {
        <Authority_Hint as ::protobuf::Message>::default_instance()
    }
}

impl Authority_Hint {
    pub fn new() -> Authority_Hint {
        ::std::default::Default::default()
    }

    // string human_readable_name = 1;


    pub fn get_human_readable_name(&self) -> &str {
        &self.human_readable_name
    }
    pub fn clear_human_readable_name(&mut self) {
        self.human_readable_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_human_readable_name(&mut self, v: ::std::string::String) {
        self.human_readable_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_human_readable_name(&mut self) -> &mut ::std::string::String {
        &mut self.human_readable_name
    }

    // Take field
    pub fn take_human_readable_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.human_readable_name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for Authority_Hint {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.human_readable_name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.human_readable_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.human_readable_name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.human_readable_name.is_empty() {
            os.write_string(1, &self.human_readable_name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Authority_Hint {
        Authority_Hint::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "human_readable_name",
                    |m: &Authority_Hint| { &m.human_readable_name },
                    |m: &mut Authority_Hint| { &mut m.human_readable_name },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Authority_Hint>(
                    "Authority_Hint",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Authority_Hint {
        static mut instance: ::protobuf::lazy::Lazy<Authority_Hint> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Authority_Hint,
        };
        unsafe {
            instance.get(Authority_Hint::new)
        }
    }
}

impl ::protobuf::Clear for Authority_Hint {
    fn clear(&mut self) {
        self.human_readable_name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Authority_Hint {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Authority_Hint {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Details {
    // message fields
    pub attestation: ::protobuf::SingularPtrField<Attestation>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Details {
    fn default() -> &'a Details {
        <Details as ::protobuf::Message>::default_instance()
    }
}

impl Details {
    pub fn new() -> Details {
        ::std::default::Default::default()
    }

    // .grafeas.v1beta1.attestation.Attestation attestation = 1;


    pub fn get_attestation(&self) -> &Attestation {
        self.attestation.as_ref().unwrap_or_else(|| Attestation::default_instance())
    }
    pub fn clear_attestation(&mut self) {
        self.attestation.clear();
    }

    pub fn has_attestation(&self) -> bool {
        self.attestation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_attestation(&mut self, v: Attestation) {
        self.attestation = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_attestation(&mut self) -> &mut Attestation {
        if self.attestation.is_none() {
            self.attestation.set_default();
        }
        self.attestation.as_mut().unwrap()
    }

    // Take field
    pub fn take_attestation(&mut self) -> Attestation {
        self.attestation.take().unwrap_or_else(|| Attestation::new())
    }
}

impl ::protobuf::Message for Details {
    fn is_initialized(&self) -> bool {
        for v in &self.attestation {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.attestation)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.attestation.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.attestation.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Details {
        Details::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Attestation>>(
                    "attestation",
                    |m: &Details| { &m.attestation },
                    |m: &mut Details| { &mut m.attestation },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Details>(
                    "Details",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Details {
        static mut instance: ::protobuf::lazy::Lazy<Details> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Details,
        };
        unsafe {
            instance.get(Details::new)
        }
    }
}

impl ::protobuf::Clear for Details {
    fn clear(&mut self) {
        self.attestation.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Details {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Details {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Attestation {
    // message oneof groups
    pub signature: ::std::option::Option<Attestation_oneof_signature>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Attestation {
    fn default() -> &'a Attestation {
        <Attestation as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum Attestation_oneof_signature {
    pgp_signed_attestation(PgpSignedAttestation),
    generic_signed_attestation(GenericSignedAttestation),
}

impl Attestation {
    pub fn new() -> Attestation {
        ::std::default::Default::default()
    }

    // .grafeas.v1beta1.attestation.PgpSignedAttestation pgp_signed_attestation = 1;


    pub fn get_pgp_signed_attestation(&self) -> &PgpSignedAttestation {
        match self.signature {
            ::std::option::Option::Some(Attestation_oneof_signature::pgp_signed_attestation(ref v)) => v,
            _ => PgpSignedAttestation::default_instance(),
        }
    }
    pub fn clear_pgp_signed_attestation(&mut self) {
        self.signature = ::std::option::Option::None;
    }

    pub fn has_pgp_signed_attestation(&self) -> bool {
        match self.signature {
            ::std::option::Option::Some(Attestation_oneof_signature::pgp_signed_attestation(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_pgp_signed_attestation(&mut self, v: PgpSignedAttestation) {
        self.signature = ::std::option::Option::Some(Attestation_oneof_signature::pgp_signed_attestation(v))
    }

    // Mutable pointer to the field.
    pub fn mut_pgp_signed_attestation(&mut self) -> &mut PgpSignedAttestation {
        if let ::std::option::Option::Some(Attestation_oneof_signature::pgp_signed_attestation(_)) = self.signature {
        } else {
            self.signature = ::std::option::Option::Some(Attestation_oneof_signature::pgp_signed_attestation(PgpSignedAttestation::new()));
        }
        match self.signature {
            ::std::option::Option::Some(Attestation_oneof_signature::pgp_signed_attestation(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_pgp_signed_attestation(&mut self) -> PgpSignedAttestation {
        if self.has_pgp_signed_attestation() {
            match self.signature.take() {
                ::std::option::Option::Some(Attestation_oneof_signature::pgp_signed_attestation(v)) => v,
                _ => panic!(),
            }
        } else {
            PgpSignedAttestation::new()
        }
    }

    // .grafeas.v1beta1.attestation.GenericSignedAttestation generic_signed_attestation = 2;


    pub fn get_generic_signed_attestation(&self) -> &GenericSignedAttestation {
        match self.signature {
            ::std::option::Option::Some(Attestation_oneof_signature::generic_signed_attestation(ref v)) => v,
            _ => GenericSignedAttestation::default_instance(),
        }
    }
    pub fn clear_generic_signed_attestation(&mut self) {
        self.signature = ::std::option::Option::None;
    }

    pub fn has_generic_signed_attestation(&self) -> bool {
        match self.signature {
            ::std::option::Option::Some(Attestation_oneof_signature::generic_signed_attestation(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_generic_signed_attestation(&mut self, v: GenericSignedAttestation) {
        self.signature = ::std::option::Option::Some(Attestation_oneof_signature::generic_signed_attestation(v))
    }

    // Mutable pointer to the field.
    pub fn mut_generic_signed_attestation(&mut self) -> &mut GenericSignedAttestation {
        if let ::std::option::Option::Some(Attestation_oneof_signature::generic_signed_attestation(_)) = self.signature {
        } else {
            self.signature = ::std::option::Option::Some(Attestation_oneof_signature::generic_signed_attestation(GenericSignedAttestation::new()));
        }
        match self.signature {
            ::std::option::Option::Some(Attestation_oneof_signature::generic_signed_attestation(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_generic_signed_attestation(&mut self) -> GenericSignedAttestation {
        if self.has_generic_signed_attestation() {
            match self.signature.take() {
                ::std::option::Option::Some(Attestation_oneof_signature::generic_signed_attestation(v)) => v,
                _ => panic!(),
            }
        } else {
            GenericSignedAttestation::new()
        }
    }
}

impl ::protobuf::Message for Attestation {
    fn is_initialized(&self) -> bool {
        if let Some(Attestation_oneof_signature::pgp_signed_attestation(ref v)) = self.signature {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Attestation_oneof_signature::generic_signed_attestation(ref v)) = self.signature {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.signature = ::std::option::Option::Some(Attestation_oneof_signature::pgp_signed_attestation(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.signature = ::std::option::Option::Some(Attestation_oneof_signature::generic_signed_attestation(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.signature {
            match v {
                &Attestation_oneof_signature::pgp_signed_attestation(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Attestation_oneof_signature::generic_signed_attestation(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.signature {
            match v {
                &Attestation_oneof_signature::pgp_signed_attestation(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Attestation_oneof_signature::generic_signed_attestation(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Attestation {
        Attestation::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, PgpSignedAttestation>(
                    "pgp_signed_attestation",
                    Attestation::has_pgp_signed_attestation,
                    Attestation::get_pgp_signed_attestation,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, GenericSignedAttestation>(
                    "generic_signed_attestation",
                    Attestation::has_generic_signed_attestation,
                    Attestation::get_generic_signed_attestation,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Attestation>(
                    "Attestation",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Attestation {
        static mut instance: ::protobuf::lazy::Lazy<Attestation> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Attestation,
        };
        unsafe {
            instance.get(Attestation::new)
        }
    }
}

impl ::protobuf::Clear for Attestation {
    fn clear(&mut self) {
        self.signature = ::std::option::Option::None;
        self.signature = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Attestation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Attestation {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x1fproto/v1beta1/attestation.proto\x12\x1bgrafeas.v1beta1.attestation\
    \x1a\x1aproto/v1beta1/common.proto\"\x86\x02\n\x14PgpSignedAttestation\
    \x12\x1c\n\tsignature\x18\x01\x20\x01(\tR\tsignature\x12`\n\x0ccontent_t\
    ype\x18\x03\x20\x01(\x0e2=.grafeas.v1beta1.attestation.PgpSignedAttestat\
    ion.ContentTypeR\x0bcontentType\x12\x1e\n\npgp_key_id\x18\x02\x20\x01(\t\
    H\0R\x08pgpKeyId\"D\n\x0bContentType\x12\x1c\n\x18CONTENT_TYPE_UNSPECIFI\
    ED\x10\0\x12\x17\n\x13SIMPLE_SIGNING_JSON\x10\x01B\x08\n\x06key_id\"\xb1\
    \x02\n\x18GenericSignedAttestation\x12d\n\x0ccontent_type\x18\x01\x20\
    \x01(\x0e2A.grafeas.v1beta1.attestation.GenericSignedAttestation.Content\
    TypeR\x0bcontentType\x12-\n\x12serialized_payload\x18\x02\x20\x01(\x0cR\
    \x11serializedPayload\x12:\n\nsignatures\x18\x03\x20\x03(\x0b2\x1a.grafe\
    as.v1beta1.SignatureR\nsignatures\"D\n\x0bContentType\x12\x1c\n\x18CONTE\
    NT_TYPE_UNSPECIFIED\x10\0\x12\x17\n\x13SIMPLE_SIGNING_JSON\x10\x01\"\x84\
    \x01\n\tAuthority\x12?\n\x04hint\x18\x01\x20\x01(\x0b2+.grafeas.v1beta1.\
    attestation.Authority.HintR\x04hint\x1a6\n\x04Hint\x12.\n\x13human_reada\
    ble_name\x18\x01\x20\x01(\tR\x11humanReadableName\"U\n\x07Details\x12J\n\
    \x0battestation\x18\x01\x20\x01(\x0b2(.grafeas.v1beta1.attestation.Attes\
    tationR\x0battestation\"\xfc\x01\n\x0bAttestation\x12i\n\x16pgp_signed_a\
    ttestation\x18\x01\x20\x01(\x0b21.grafeas.v1beta1.attestation.PgpSignedA\
    ttestationH\0R\x14pgpSignedAttestation\x12u\n\x1ageneric_signed_attestat\
    ion\x18\x02\x20\x01(\x0b25.grafeas.v1beta1.attestation.GenericSignedAtte\
    stationH\0R\x18genericSignedAttestationB\x0b\n\tsignatureBg\n\x1eio.graf\
    eas.v1beta1.attestationP\x01Z=github.com/grafeas/grafeas/proto/v1beta1/a\
    ttestation_go_proto\xa2\x02\x03GRAJ\xf8@\n\x07\x12\x05\x0e\0\xad\x01\x01\
    \n\xda\x04\n\x01\x0c\x12\x03\x0e\0\x122\xcf\x04\x20Copyright\x202018\x20\
    The\x20Grafeas\x20Authors.\x20All\x20rights\x20reserved.\n\n\x20Licensed\
    \x20under\x20the\x20Apache\x20License,\x20Version\x202.0\x20(the\x20\"Li\
    cense\");\n\x20you\x20may\x20not\x20use\x20this\x20file\x20except\x20in\
    \x20compliance\x20with\x20the\x20License.\n\x20You\x20may\x20obtain\x20a\
    \x20copy\x20of\x20the\x20License\x20at\n\n\x20\x20\x20\x20http://www.apa\
    che.org/licenses/LICENSE-2.0\n\n\x20Unless\x20required\x20by\x20applicab\
    le\x20law\x20or\x20agreed\x20to\x20in\x20writing,\x20software\n\x20distr\
    ibuted\x20under\x20the\x20License\x20is\x20distributed\x20on\x20an\x20\"\
    AS\x20IS\"\x20BASIS,\n\x20WITHOUT\x20WARRANTIES\x20OR\x20CONDITIONS\x20O\
    F\x20ANY\x20KIND,\x20either\x20express\x20or\x20implied.\n\x20See\x20the\
    \x20License\x20for\x20the\x20specific\x20language\x20governing\x20permis\
    sions\x20and\n\x20limitations\x20under\x20the\x20License.\n\n\x08\n\x01\
    \x02\x12\x03\x10\0$\n\x08\n\x01\x08\x12\x03\x12\0T\n\t\n\x02\x08\x0b\x12\
    \x03\x12\0T\n\x08\n\x01\x08\x12\x03\x13\0\"\n\t\n\x02\x08\n\x12\x03\x13\
    \0\"\n\x08\n\x01\x08\x12\x03\x14\07\n\t\n\x02\x08\x01\x12\x03\x14\07\n\
    \x08\n\x01\x08\x12\x03\x15\0!\n\t\n\x02\x08$\x12\x03\x15\0!\n\t\n\x02\
    \x03\0\x12\x03\x17\0$\n\xd8\x01\n\x02\x04\0\x12\x04\x1c\0T\x01\x1a\xcb\
    \x01\x20An\x20attestation\x20wrapper\x20with\x20a\x20PGP-compatible\x20s\
    ignature.\x20This\x20message\x20only\n\x20supports\x20`ATTACHED`\x20sign\
    atures,\x20where\x20the\x20payload\x20that\x20is\x20signed\x20is\x20incl\
    uded\n\x20alongside\x20the\x20signature\x20itself\x20in\x20the\x20same\
    \x20file.\n\n\n\n\x03\x04\0\x01\x12\x03\x1c\x08\x1c\n\xea\x04\n\x04\x04\
    \0\x02\0\x12\x03&\x02\x17\x1a\xdc\x04\x20Required.\x20The\x20raw\x20cont\
    ent\x20of\x20the\x20signature,\x20as\x20output\x20by\x20GNU\x20Privacy\
    \x20Guard\n\x20(GPG)\x20or\x20equivalent.\x20Since\x20this\x20message\
    \x20only\x20supports\x20attached\x20signatures,\n\x20the\x20payload\x20t\
    hat\x20was\x20signed\x20must\x20be\x20attached.\x20While\x20the\x20signa\
    ture\x20format\n\x20supported\x20is\x20dependent\x20on\x20the\x20verific\
    ation\x20implementation,\x20currently\x20only\n\x20ASCII-armored\x20(`--\
    armor`\x20to\x20gpg),\x20non-clearsigned\x20(`--sign`\x20rather\x20than\
    \n\x20`--clearsign`\x20to\x20gpg)\x20are\x20supported.\x20Concretely,\
    \x20`gpg\x20--sign\x20--armor\n\x20--output=signature.gpg\x20payload.jso\
    n`\x20will\x20create\x20the\x20signature\x20content\n\x20expected\x20in\
    \x20this\x20field\x20in\x20`signature.gpg`\x20for\x20the\x20`payload.jso\
    n`\n\x20attestation\x20payload.\n\n\r\n\x05\x04\0\x02\0\x04\x12\x04&\x02\
    \x1c\x1e\n\x0c\n\x05\x04\0\x02\0\x05\x12\x03&\x02\x08\n\x0c\n\x05\x04\0\
    \x02\0\x01\x12\x03&\t\x12\n\x0c\n\x05\x04\0\x02\0\x03\x12\x03&\x15\x16\n\
    U\n\x04\x04\0\x04\0\x12\x04)\x021\x03\x1aG\x20Type\x20(for\x20example\
    \x20schema)\x20of\x20the\x20attestation\x20payload\x20that\x20was\x20sig\
    ned.\n\n\x0c\n\x05\x04\0\x04\0\x01\x12\x03)\x07\x12\n*\n\x06\x04\0\x04\0\
    \x02\0\x12\x03+\x04!\x1a\x1b\x20`ContentType`\x20is\x20not\x20set.\n\n\
    \x0e\n\x07\x04\0\x04\0\x02\0\x01\x12\x03+\x04\x1c\n\x0e\n\x07\x04\0\x04\
    \0\x02\0\x02\x12\x03+\x1f\x20\n\xff\x01\n\x06\x04\0\x04\0\x02\x01\x12\
    \x030\x04\x1c\x1a\xef\x01\x20Atomic\x20format\x20attestation\x20signatur\
    e.\x20See\n\x20https://github.com/containers/image/blob/8a5d2f82a6e32632\
    90c8e0276c3e0f64e77723e7/docs/atomic-signature.md\n\x20The\x20payload\
    \x20extracted\x20from\x20`signature`\x20is\x20a\x20JSON\x20blob\x20confo\
    rming\x20to\x20the\n\x20linked\x20schema.\n\n\x0e\n\x07\x04\0\x04\0\x02\
    \x01\x01\x12\x030\x04\x17\n\x0e\n\x07\x04\0\x04\0\x02\x01\x02\x12\x030\
    \x1a\x1b\n\x9d\x02\n\x04\x04\0\x02\x01\x12\x037\x02\x1f\x1a\x8f\x02\x20T\
    ype\x20(for\x20example\x20schema)\x20of\x20the\x20attestation\x20payload\
    \x20that\x20was\x20signed.\n\x20The\x20verifier\x20must\x20ensure\x20tha\
    t\x20the\x20provided\x20type\x20is\x20one\x20that\x20the\x20verifier\n\
    \x20supports,\x20and\x20that\x20the\x20attestation\x20payload\x20is\x20a\
    \x20valid\x20instantiation\x20of\x20that\n\x20type\x20(for\x20example\
    \x20by\x20validating\x20a\x20JSON\x20schema).\n\n\r\n\x05\x04\0\x02\x01\
    \x04\x12\x047\x021\x03\n\x0c\n\x05\x04\0\x02\x01\x06\x12\x037\x02\r\n\
    \x0c\n\x05\x04\0\x02\x01\x01\x12\x037\x0e\x1a\n\x0c\n\x05\x04\0\x02\x01\
    \x03\x12\x037\x1d\x1e\n\x9e\x04\n\x04\x04\0\x08\0\x12\x04A\x02S\x03\x1a\
    \x8f\x04\x20This\x20field\x20is\x20used\x20by\x20verifiers\x20to\x20sele\
    ct\x20the\x20public\x20key\x20used\x20to\x20validate\n\x20the\x20signatu\
    re.\x20Note\x20that\x20the\x20policy\x20of\x20the\x20verifier\x20ultimat\
    ely\x20determines\n\x20which\x20public\x20keys\x20verify\x20a\x20signatu\
    re\x20based\x20on\x20the\x20context\x20of\x20the\n\x20verification.\x20T\
    here\x20is\x20no\x20guarantee\x20validation\x20will\x20succeed\x20if\x20\
    the\n\x20verifier\x20has\x20no\x20key\x20matching\x20this\x20ID,\x20even\
    \x20if\x20it\x20has\x20a\x20key\x20under\x20a\n\x20different\x20ID\x20th\
    at\x20would\x20verify\x20the\x20signature.\x20Note\x20that\x20this\x20ID\
    \x20should\x20also\n\x20be\x20present\x20in\x20the\x20signature\x20conte\
    nt\x20above,\x20but\x20that\x20is\x20not\x20expected\x20to\x20be\n\x20us\
    ed\x20by\x20the\x20verifier.\n\n\x0c\n\x05\x04\0\x08\0\x01\x12\x03A\x08\
    \x0e\n\xd8\x06\n\x04\x04\0\x02\x02\x12\x03R\x04\x1a\x1a\xca\x06\x20The\
    \x20cryptographic\x20fingerprint\x20of\x20the\x20key\x20used\x20to\x20ge\
    nerate\x20the\x20signature,\n\x20as\x20output\x20by,\x20e.g.\x20`gpg\x20\
    --list-keys`.\x20This\x20should\x20be\x20the\x20version\x204,\x20full\n\
    \x20160-bit\x20fingerprint,\x20expressed\x20as\x20a\x2040\x20character\
    \x20hexidecimal\x20string.\x20See\n\x20https://tools.ietf.org/html/rfc48\
    80#section-12.2\x20for\x20details.\n\x20Implementations\x20may\x20choose\
    \x20to\x20acknowledge\x20\"LONG\",\x20\"SHORT\",\x20or\x20other\n\x20abb\
    reviated\x20key\x20IDs,\x20but\x20only\x20the\x20full\x20fingerprint\x20\
    is\x20guaranteed\x20to\x20work.\n\x20In\x20gpg,\x20the\x20full\x20finger\
    print\x20can\x20be\x20retrieved\x20from\x20the\x20`fpr`\x20field\n\x20re\
    turned\x20when\x20calling\x20--list-keys\x20with\x20--with-colons.\x20\
    \x20For\x20example:\n\x20```\n\x20gpg\x20--with-colons\x20--with-fingerp\
    rint\x20--force-v4-certs\x20\\\n\x20\x20\x20\x20\x20--list-keys\x20attes\
    ter@example.com\n\x20tru::1:1513631572:0:3:1:5\n\x20pub:...<SNIP>...\n\
    \x20fpr:::::::::24FF6481B76AC91E66A00AC657A93A81EF3AE6FB:\n\x20```\n\x20\
    Above,\x20the\x20fingerprint\x20is\x20`24FF6481B76AC91E66A00AC657A93A81E\
    F3AE6FB`.\n\n\x0c\n\x05\x04\0\x02\x02\x05\x12\x03R\x04\n\n\x0c\n\x05\x04\
    \0\x02\x02\x01\x12\x03R\x0b\x15\n\x0c\n\x05\x04\0\x02\x02\x03\x12\x03R\
    \x18\x19\n\xa9\x02\n\x02\x04\x01\x12\x04Z\0v\x01\x1a\x9c\x02\x20An\x20at\
    testation\x20wrapper\x20that\x20uses\x20the\x20Grafeas\x20`Signature`\
    \x20message.\n\x20This\x20attestation\x20must\x20define\x20the\x20`seria\
    lized_payload`\x20that\x20the\x20`signatures`\x20verify\n\x20and\x20any\
    \x20metadata\x20necessary\x20to\x20interpret\x20that\x20plaintext.\x20\
    \x20The\x20signatures\n\x20should\x20always\x20be\x20over\x20the\x20`ser\
    ialized_payload`\x20bytestring.\n\n\n\n\x03\x04\x01\x01\x12\x03Z\x08\x20\
    \nB\n\x04\x04\x01\x04\0\x12\x04\\\x02d\x03\x1a4\x20Type\x20of\x20the\x20\
    attestation\x20plaintext\x20that\x20was\x20signed.\n\n\x0c\n\x05\x04\x01\
    \x04\0\x01\x12\x03\\\x07\x12\n*\n\x06\x04\x01\x04\0\x02\0\x12\x03^\x04!\
    \x1a\x1b\x20`ContentType`\x20is\x20not\x20set.\n\n\x0e\n\x07\x04\x01\x04\
    \0\x02\0\x01\x12\x03^\x04\x1c\n\x0e\n\x07\x04\x01\x04\0\x02\0\x02\x12\
    \x03^\x1f\x20\n\xfd\x01\n\x06\x04\x01\x04\0\x02\x01\x12\x03c\x04\x1c\x1a\
    \xed\x01\x20Atomic\x20format\x20attestation\x20signature.\x20See\n\x20ht\
    tps://github.com/containers/image/blob/8a5d2f82a6e3263290c8e0276c3e0f64e\
    77723e7/docs/atomic-signature.md\n\x20The\x20payload\x20extracted\x20in\
    \x20`plaintext`\x20is\x20a\x20JSON\x20blob\x20conforming\x20to\x20the\n\
    \x20linked\x20schema.\n\n\x0e\n\x07\x04\x01\x04\0\x02\x01\x01\x12\x03c\
    \x04\x17\n\x0e\n\x07\x04\x01\x04\0\x02\x01\x02\x12\x03c\x1a\x1b\n\x9d\
    \x02\n\x04\x04\x01\x02\0\x12\x03j\x02\x1f\x1a\x8f\x02\x20Type\x20(for\
    \x20example\x20schema)\x20of\x20the\x20attestation\x20payload\x20that\
    \x20was\x20signed.\n\x20The\x20verifier\x20must\x20ensure\x20that\x20the\
    \x20provided\x20type\x20is\x20one\x20that\x20the\x20verifier\n\x20suppor\
    ts,\x20and\x20that\x20the\x20attestation\x20payload\x20is\x20a\x20valid\
    \x20instantiation\x20of\x20that\n\x20type\x20(for\x20example\x20by\x20va\
    lidating\x20a\x20JSON\x20schema).\n\n\r\n\x05\x04\x01\x02\0\x04\x12\x04j\
    \x02d\x03\n\x0c\n\x05\x04\x01\x02\0\x06\x12\x03j\x02\r\n\x0c\n\x05\x04\
    \x01\x02\0\x01\x12\x03j\x0e\x1a\n\x0c\n\x05\x04\x01\x02\0\x03\x12\x03j\
    \x1d\x1e\n\xb2\x01\n\x04\x04\x01\x02\x01\x12\x03o\x02\x1f\x1a\xa4\x01\
    \x20The\x20serialized\x20payload\x20that\x20is\x20verified\x20by\x20one\
    \x20or\x20more\x20`signatures`.\n\x20The\x20encoding\x20and\x20semantic\
    \x20meaning\x20of\x20this\x20payload\x20must\x20match\x20what\x20is\x20s\
    et\x20in\n\x20`content_type`.\n\n\r\n\x05\x04\x01\x02\x01\x04\x12\x04o\
    \x02j\x1f\n\x0c\n\x05\x04\x01\x02\x01\x05\x12\x03o\x02\x07\n\x0c\n\x05\
    \x04\x01\x02\x01\x01\x12\x03o\x08\x1a\n\x0c\n\x05\x04\x01\x02\x01\x03\
    \x12\x03o\x1d\x1e\n\xa6\x02\n\x04\x04\x01\x02\x02\x12\x03u\x02$\x1a\x98\
    \x02\x20One\x20or\x20more\x20signatures\x20over\x20`serialized_payload`.\
    \x20\x20Verifier\x20implementations\n\x20should\x20consider\x20this\x20a\
    ttestation\x20message\x20verified\x20if\x20at\x20least\x20one\n\x20`sign\
    ature`\x20verifies\x20`serialized_payload`.\x20\x20See\x20`Signature`\
    \x20in\x20common.proto\n\x20for\x20more\x20details\x20on\x20signature\
    \x20structure\x20and\x20verification.\n\n\x0c\n\x05\x04\x01\x02\x02\x04\
    \x12\x03u\x02\n\n\x0c\n\x05\x04\x01\x02\x02\x06\x12\x03u\x0b\x14\n\x0c\n\
    \x05\x04\x01\x02\x02\x01\x12\x03u\x15\x1f\n\x0c\n\x05\x04\x01\x02\x02\
    \x03\x12\x03u\"#\n\xbc\x04\n\x02\x04\x02\x12\x06\x80\x01\0\x90\x01\x01\
    \x1a\xad\x04\x20Note\x20kind\x20that\x20represents\x20a\x20logical\x20at\
    testation\x20\"role\"\x20or\x20\"authority\".\x20For\n\x20example,\x20an\
    \x20organization\x20might\x20have\x20one\x20`Authority`\x20for\x20\"QA\"\
    \x20and\x20one\x20for\n\x20\"build\".\x20This\x20note\x20is\x20intended\
    \x20to\x20act\x20strictly\x20as\x20a\x20grouping\x20mechanism\x20for\n\
    \x20the\x20attached\x20occurrences\x20(Attestations).\x20This\x20groupin\
    g\x20mechanism\x20also\n\x20provides\x20a\x20security\x20boundary,\x20si\
    nce\x20IAM\x20ACLs\x20gate\x20the\x20ability\x20for\x20a\x20principle\n\
    \x20to\x20attach\x20an\x20occurrence\x20to\x20a\x20given\x20note.\x20It\
    \x20also\x20provides\x20a\x20single\x20point\x20of\n\x20lookup\x20to\x20\
    find\x20all\x20attached\x20attestation\x20occurrences,\x20even\x20if\x20\
    they\x20don't\x20all\n\x20live\x20in\x20the\x20same\x20project.\n\n\x0b\
    \n\x03\x04\x02\x01\x12\x04\x80\x01\x08\x11\n\xd8\x03\n\x04\x04\x02\x03\0\
    \x12\x06\x88\x01\x02\x8c\x01\x03\x1a\xc7\x03\x20This\x20submessage\x20pr\
    ovides\x20human-readable\x20hints\x20about\x20the\x20purpose\x20of\x20th\
    e\n\x20authority.\x20Because\x20the\x20name\x20of\x20a\x20note\x20acts\
    \x20as\x20its\x20resource\x20reference,\x20it\x20is\n\x20important\x20to\
    \x20disambiguate\x20the\x20canonical\x20name\x20of\x20the\x20Note\x20(wh\
    ich\x20might\x20be\x20a\n\x20UUID\x20for\x20security\x20purposes)\x20fro\
    m\x20\"readable\"\x20names\x20more\x20suitable\x20for\x20debug\n\x20outp\
    ut.\x20Note\x20that\x20these\x20hints\x20should\x20not\x20be\x20used\x20\
    to\x20look\x20up\x20authorities\x20in\n\x20security\x20sensitive\x20cont\
    exts,\x20such\x20as\x20when\x20looking\x20up\x20attestations\x20to\n\x20\
    verify.\n\n\r\n\x05\x04\x02\x03\0\x01\x12\x04\x88\x01\n\x0e\ne\n\x06\x04\
    \x02\x03\0\x02\0\x12\x04\x8b\x01\x04#\x1aU\x20Required.\x20The\x20human\
    \x20readable\x20name\x20of\x20this\x20attestation\x20authority,\x20for\n\
    \x20example\x20\"qa\".\n\n\x11\n\x07\x04\x02\x03\0\x02\0\x04\x12\x06\x8b\
    \x01\x04\x88\x01\x10\n\x0f\n\x07\x04\x02\x03\0\x02\0\x05\x12\x04\x8b\x01\
    \x04\n\n\x0f\n\x07\x04\x02\x03\0\x02\0\x01\x12\x04\x8b\x01\x0b\x1e\n\x0f\
    \n\x07\x04\x02\x03\0\x02\0\x03\x12\x04\x8b\x01!\"\nG\n\x04\x04\x02\x02\0\
    \x12\x04\x8f\x01\x02\x10\x1a9\x20Hint\x20hints\x20at\x20the\x20purpose\
    \x20of\x20the\x20attestation\x20authority.\n\n\x0f\n\x05\x04\x02\x02\0\
    \x04\x12\x06\x8f\x01\x02\x8c\x01\x03\n\r\n\x05\x04\x02\x02\0\x06\x12\x04\
    \x8f\x01\x02\x06\n\r\n\x05\x04\x02\x02\0\x01\x12\x04\x8f\x01\x07\x0b\n\r\
    \n\x05\x04\x02\x02\0\x03\x12\x04\x8f\x01\x0e\x0f\n5\n\x02\x04\x03\x12\
    \x06\x93\x01\0\x96\x01\x01\x1a'\x20Details\x20of\x20an\x20attestation\
    \x20occurrence.\n\n\x0b\n\x03\x04\x03\x01\x12\x04\x93\x01\x08\x0f\n7\n\
    \x04\x04\x03\x02\0\x12\x04\x95\x01\x02\x1e\x1a)\x20Required.\x20Attestat\
    ion\x20for\x20the\x20resource.\n\n\x0f\n\x05\x04\x03\x02\0\x04\x12\x06\
    \x95\x01\x02\x93\x01\x11\n\r\n\x05\x04\x03\x02\0\x06\x12\x04\x95\x01\x02\
    \r\n\r\n\x05\x04\x03\x02\0\x01\x12\x04\x95\x01\x0e\x19\n\r\n\x05\x04\x03\
    \x02\0\x03\x12\x04\x95\x01\x1c\x1d\n\x9e\x04\n\x02\x04\x04\x12\x06\xa0\
    \x01\0\xad\x01\x01\x1a\x8f\x04\x20Occurrence\x20that\x20represents\x20a\
    \x20single\x20\"attestation\".\x20The\x20authenticity\x20of\x20an\n\x20a\
    ttestation\x20can\x20be\x20verified\x20using\x20the\x20attached\x20signa\
    ture.\x20If\x20the\x20verifier\n\x20trusts\x20the\x20public\x20key\x20of\
    \x20the\x20signer,\x20then\x20verifying\x20the\x20signature\x20is\n\x20s\
    ufficient\x20to\x20establish\x20trust.\x20In\x20this\x20circumstance,\
    \x20the\x20authority\x20to\x20which\n\x20this\x20attestation\x20is\x20at\
    tached\x20is\x20primarily\x20useful\x20for\x20look-up\x20(how\x20to\x20f\
    ind\n\x20this\x20attestation\x20if\x20you\x20already\x20know\x20the\x20a\
    uthority\x20and\x20artifact\x20to\x20be\n\x20verified)\x20and\x20intent\
    \x20(which\x20authority\x20was\x20this\x20attestation\x20intended\x20to\
    \x20sign\n\x20for).\n\n\x0b\n\x03\x04\x04\x01\x12\x04\xa0\x01\x08\x13\n\
    \xce\x01\n\x04\x04\x04\x08\0\x12\x06\xa4\x01\x02\xac\x01\x03\x1a\xbd\x01\
    \x20Required.\x20The\x20signature,\x20generally\x20over\x20the\x20`resou\
    rce_url`,\x20that\x20verifies\n\x20this\x20attestation.\x20The\x20semant\
    ics\x20of\x20the\x20signature\x20veracity\x20are\x20ultimately\n\x20dete\
    rmined\x20by\x20the\x20verification\x20engine.\n\n\r\n\x05\x04\x04\x08\0\
    \x01\x12\x04\xa4\x01\x08\x11\n)\n\x04\x04\x04\x02\0\x12\x04\xa6\x01\x044\
    \x1a\x1b\x20A\x20PGP\x20signed\x20attestation.\n\n\r\n\x05\x04\x04\x02\0\
    \x06\x12\x04\xa6\x01\x04\x18\n\r\n\x05\x04\x04\x02\0\x01\x12\x04\xa6\x01\
    \x19/\n\r\n\x05\x04\x04\x02\0\x03\x12\x04\xa6\x0123\n\xe3\x01\n\x04\x04\
    \x04\x02\x01\x12\x04\xab\x01\x04<\x1a\xd4\x01\x20An\x20attestation\x20th\
    at\x20supports\x20multiple\x20`Signature`s\n\x20over\x20the\x20same\x20a\
    ttestation\x20payload.\x20The\x20signatures\n\x20(defined\x20in\x20commo\
    n.proto)\x20support\x20a\x20superset\x20of\n\x20public\x20key\x20types\
    \x20and\x20IDs\x20compared\x20to\x20PgpSignedAttestation.\n\n\r\n\x05\
    \x04\x04\x02\x01\x06\x12\x04\xab\x01\x04\x1c\n\r\n\x05\x04\x04\x02\x01\
    \x01\x12\x04\xab\x01\x1d7\n\r\n\x05\x04\x04\x02\x01\x03\x12\x04\xab\x01:\
    ;b\x06proto3\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
