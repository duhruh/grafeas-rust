// This file is generated by rust-protobuf 2.6.0. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

#[derive(PartialEq,Clone,Default)]
pub struct Vulnerability {
    // message fields
    pub cvss_score: f32,
    pub severity: Severity,
    pub details: ::protobuf::RepeatedField<Vulnerability_Detail>,
    pub cvss_v3: ::protobuf::SingularPtrField<super::cvss::CVSSv3>,
    pub windows_details: ::protobuf::RepeatedField<Vulnerability_WindowsDetail>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Vulnerability {
    fn default() -> &'a Vulnerability {
        <Vulnerability as ::protobuf::Message>::default_instance()
    }
}

impl Vulnerability {
    pub fn new() -> Vulnerability {
        ::std::default::Default::default()
    }

    // float cvss_score = 1;


    pub fn get_cvss_score(&self) -> f32 {
        self.cvss_score
    }
    pub fn clear_cvss_score(&mut self) {
        self.cvss_score = 0.;
    }

    // Param is passed by value, moved
    pub fn set_cvss_score(&mut self, v: f32) {
        self.cvss_score = v;
    }

    // .grafeas.v1beta1.vulnerability.Severity severity = 2;


    pub fn get_severity(&self) -> Severity {
        self.severity
    }
    pub fn clear_severity(&mut self) {
        self.severity = Severity::SEVERITY_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_severity(&mut self, v: Severity) {
        self.severity = v;
    }

    // repeated .grafeas.v1beta1.vulnerability.Vulnerability.Detail details = 3;


    pub fn get_details(&self) -> &[Vulnerability_Detail] {
        &self.details
    }
    pub fn clear_details(&mut self) {
        self.details.clear();
    }

    // Param is passed by value, moved
    pub fn set_details(&mut self, v: ::protobuf::RepeatedField<Vulnerability_Detail>) {
        self.details = v;
    }

    // Mutable pointer to the field.
    pub fn mut_details(&mut self) -> &mut ::protobuf::RepeatedField<Vulnerability_Detail> {
        &mut self.details
    }

    // Take field
    pub fn take_details(&mut self) -> ::protobuf::RepeatedField<Vulnerability_Detail> {
        ::std::mem::replace(&mut self.details, ::protobuf::RepeatedField::new())
    }

    // .grafeas.v1beta1.vulnerability.CVSSv3 cvss_v3 = 4;


    pub fn get_cvss_v3(&self) -> &super::cvss::CVSSv3 {
        self.cvss_v3.as_ref().unwrap_or_else(|| super::cvss::CVSSv3::default_instance())
    }
    pub fn clear_cvss_v3(&mut self) {
        self.cvss_v3.clear();
    }

    pub fn has_cvss_v3(&self) -> bool {
        self.cvss_v3.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cvss_v3(&mut self, v: super::cvss::CVSSv3) {
        self.cvss_v3 = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cvss_v3(&mut self) -> &mut super::cvss::CVSSv3 {
        if self.cvss_v3.is_none() {
            self.cvss_v3.set_default();
        }
        self.cvss_v3.as_mut().unwrap()
    }

    // Take field
    pub fn take_cvss_v3(&mut self) -> super::cvss::CVSSv3 {
        self.cvss_v3.take().unwrap_or_else(|| super::cvss::CVSSv3::new())
    }

    // repeated .grafeas.v1beta1.vulnerability.Vulnerability.WindowsDetail windows_details = 5;


    pub fn get_windows_details(&self) -> &[Vulnerability_WindowsDetail] {
        &self.windows_details
    }
    pub fn clear_windows_details(&mut self) {
        self.windows_details.clear();
    }

    // Param is passed by value, moved
    pub fn set_windows_details(&mut self, v: ::protobuf::RepeatedField<Vulnerability_WindowsDetail>) {
        self.windows_details = v;
    }

    // Mutable pointer to the field.
    pub fn mut_windows_details(&mut self) -> &mut ::protobuf::RepeatedField<Vulnerability_WindowsDetail> {
        &mut self.windows_details
    }

    // Take field
    pub fn take_windows_details(&mut self) -> ::protobuf::RepeatedField<Vulnerability_WindowsDetail> {
        ::std::mem::replace(&mut self.windows_details, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Vulnerability {
    fn is_initialized(&self) -> bool {
        for v in &self.details {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.cvss_v3 {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.windows_details {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.cvss_score = tmp;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.severity, 2, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.details)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.cvss_v3)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.windows_details)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.cvss_score != 0. {
            my_size += 5;
        }
        if self.severity != Severity::SEVERITY_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(2, self.severity);
        }
        for value in &self.details {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.cvss_v3.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.windows_details {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.cvss_score != 0. {
            os.write_float(1, self.cvss_score)?;
        }
        if self.severity != Severity::SEVERITY_UNSPECIFIED {
            os.write_enum(2, self.severity.value())?;
        }
        for v in &self.details {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.cvss_v3.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.windows_details {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Vulnerability {
        Vulnerability::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "cvss_score",
                    |m: &Vulnerability| { &m.cvss_score },
                    |m: &mut Vulnerability| { &mut m.cvss_score },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Severity>>(
                    "severity",
                    |m: &Vulnerability| { &m.severity },
                    |m: &mut Vulnerability| { &mut m.severity },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Vulnerability_Detail>>(
                    "details",
                    |m: &Vulnerability| { &m.details },
                    |m: &mut Vulnerability| { &mut m.details },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::cvss::CVSSv3>>(
                    "cvss_v3",
                    |m: &Vulnerability| { &m.cvss_v3 },
                    |m: &mut Vulnerability| { &mut m.cvss_v3 },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Vulnerability_WindowsDetail>>(
                    "windows_details",
                    |m: &Vulnerability| { &m.windows_details },
                    |m: &mut Vulnerability| { &mut m.windows_details },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Vulnerability>(
                    "Vulnerability",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Vulnerability {
        static mut instance: ::protobuf::lazy::Lazy<Vulnerability> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Vulnerability,
        };
        unsafe {
            instance.get(Vulnerability::new)
        }
    }
}

impl ::protobuf::Clear for Vulnerability {
    fn clear(&mut self) {
        self.cvss_score = 0.;
        self.severity = Severity::SEVERITY_UNSPECIFIED;
        self.details.clear();
        self.cvss_v3.clear();
        self.windows_details.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Vulnerability {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Vulnerability {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Vulnerability_Detail {
    // message fields
    pub cpe_uri: ::std::string::String,
    pub package: ::std::string::String,
    pub min_affected_version: ::protobuf::SingularPtrField<super::package::Version>,
    pub max_affected_version: ::protobuf::SingularPtrField<super::package::Version>,
    pub severity_name: ::std::string::String,
    pub description: ::std::string::String,
    pub fixed_location: ::protobuf::SingularPtrField<VulnerabilityLocation>,
    pub package_type: ::std::string::String,
    pub is_obsolete: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Vulnerability_Detail {
    fn default() -> &'a Vulnerability_Detail {
        <Vulnerability_Detail as ::protobuf::Message>::default_instance()
    }
}

impl Vulnerability_Detail {
    pub fn new() -> Vulnerability_Detail {
        ::std::default::Default::default()
    }

    // string cpe_uri = 1;


    pub fn get_cpe_uri(&self) -> &str {
        &self.cpe_uri
    }
    pub fn clear_cpe_uri(&mut self) {
        self.cpe_uri.clear();
    }

    // Param is passed by value, moved
    pub fn set_cpe_uri(&mut self, v: ::std::string::String) {
        self.cpe_uri = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cpe_uri(&mut self) -> &mut ::std::string::String {
        &mut self.cpe_uri
    }

    // Take field
    pub fn take_cpe_uri(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.cpe_uri, ::std::string::String::new())
    }

    // string package = 2;


    pub fn get_package(&self) -> &str {
        &self.package
    }
    pub fn clear_package(&mut self) {
        self.package.clear();
    }

    // Param is passed by value, moved
    pub fn set_package(&mut self, v: ::std::string::String) {
        self.package = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_package(&mut self) -> &mut ::std::string::String {
        &mut self.package
    }

    // Take field
    pub fn take_package(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.package, ::std::string::String::new())
    }

    // .grafeas.v1beta1.package.Version min_affected_version = 3;


    pub fn get_min_affected_version(&self) -> &super::package::Version {
        self.min_affected_version.as_ref().unwrap_or_else(|| super::package::Version::default_instance())
    }
    pub fn clear_min_affected_version(&mut self) {
        self.min_affected_version.clear();
    }

    pub fn has_min_affected_version(&self) -> bool {
        self.min_affected_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_min_affected_version(&mut self, v: super::package::Version) {
        self.min_affected_version = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_min_affected_version(&mut self) -> &mut super::package::Version {
        if self.min_affected_version.is_none() {
            self.min_affected_version.set_default();
        }
        self.min_affected_version.as_mut().unwrap()
    }

    // Take field
    pub fn take_min_affected_version(&mut self) -> super::package::Version {
        self.min_affected_version.take().unwrap_or_else(|| super::package::Version::new())
    }

    // .grafeas.v1beta1.package.Version max_affected_version = 4;


    pub fn get_max_affected_version(&self) -> &super::package::Version {
        self.max_affected_version.as_ref().unwrap_or_else(|| super::package::Version::default_instance())
    }
    pub fn clear_max_affected_version(&mut self) {
        self.max_affected_version.clear();
    }

    pub fn has_max_affected_version(&self) -> bool {
        self.max_affected_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_affected_version(&mut self, v: super::package::Version) {
        self.max_affected_version = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_max_affected_version(&mut self) -> &mut super::package::Version {
        if self.max_affected_version.is_none() {
            self.max_affected_version.set_default();
        }
        self.max_affected_version.as_mut().unwrap()
    }

    // Take field
    pub fn take_max_affected_version(&mut self) -> super::package::Version {
        self.max_affected_version.take().unwrap_or_else(|| super::package::Version::new())
    }

    // string severity_name = 5;


    pub fn get_severity_name(&self) -> &str {
        &self.severity_name
    }
    pub fn clear_severity_name(&mut self) {
        self.severity_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_severity_name(&mut self, v: ::std::string::String) {
        self.severity_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_severity_name(&mut self) -> &mut ::std::string::String {
        &mut self.severity_name
    }

    // Take field
    pub fn take_severity_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.severity_name, ::std::string::String::new())
    }

    // string description = 6;


    pub fn get_description(&self) -> &str {
        &self.description
    }
    pub fn clear_description(&mut self) {
        self.description.clear();
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        &mut self.description
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.description, ::std::string::String::new())
    }

    // .grafeas.v1beta1.vulnerability.VulnerabilityLocation fixed_location = 7;


    pub fn get_fixed_location(&self) -> &VulnerabilityLocation {
        self.fixed_location.as_ref().unwrap_or_else(|| VulnerabilityLocation::default_instance())
    }
    pub fn clear_fixed_location(&mut self) {
        self.fixed_location.clear();
    }

    pub fn has_fixed_location(&self) -> bool {
        self.fixed_location.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fixed_location(&mut self, v: VulnerabilityLocation) {
        self.fixed_location = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fixed_location(&mut self) -> &mut VulnerabilityLocation {
        if self.fixed_location.is_none() {
            self.fixed_location.set_default();
        }
        self.fixed_location.as_mut().unwrap()
    }

    // Take field
    pub fn take_fixed_location(&mut self) -> VulnerabilityLocation {
        self.fixed_location.take().unwrap_or_else(|| VulnerabilityLocation::new())
    }

    // string package_type = 8;


    pub fn get_package_type(&self) -> &str {
        &self.package_type
    }
    pub fn clear_package_type(&mut self) {
        self.package_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_package_type(&mut self, v: ::std::string::String) {
        self.package_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_package_type(&mut self) -> &mut ::std::string::String {
        &mut self.package_type
    }

    // Take field
    pub fn take_package_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.package_type, ::std::string::String::new())
    }

    // bool is_obsolete = 9;


    pub fn get_is_obsolete(&self) -> bool {
        self.is_obsolete
    }
    pub fn clear_is_obsolete(&mut self) {
        self.is_obsolete = false;
    }

    // Param is passed by value, moved
    pub fn set_is_obsolete(&mut self, v: bool) {
        self.is_obsolete = v;
    }
}

impl ::protobuf::Message for Vulnerability_Detail {
    fn is_initialized(&self) -> bool {
        for v in &self.min_affected_version {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.max_affected_version {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.fixed_location {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.cpe_uri)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.package)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.min_affected_version)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.max_affected_version)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.severity_name)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.description)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.fixed_location)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.package_type)?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_obsolete = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.cpe_uri.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.cpe_uri);
        }
        if !self.package.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.package);
        }
        if let Some(ref v) = self.min_affected_version.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.max_affected_version.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.severity_name.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.severity_name);
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.description);
        }
        if let Some(ref v) = self.fixed_location.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.package_type.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.package_type);
        }
        if self.is_obsolete != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.cpe_uri.is_empty() {
            os.write_string(1, &self.cpe_uri)?;
        }
        if !self.package.is_empty() {
            os.write_string(2, &self.package)?;
        }
        if let Some(ref v) = self.min_affected_version.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.max_affected_version.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.severity_name.is_empty() {
            os.write_string(5, &self.severity_name)?;
        }
        if !self.description.is_empty() {
            os.write_string(6, &self.description)?;
        }
        if let Some(ref v) = self.fixed_location.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.package_type.is_empty() {
            os.write_string(8, &self.package_type)?;
        }
        if self.is_obsolete != false {
            os.write_bool(9, self.is_obsolete)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Vulnerability_Detail {
        Vulnerability_Detail::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "cpe_uri",
                    |m: &Vulnerability_Detail| { &m.cpe_uri },
                    |m: &mut Vulnerability_Detail| { &mut m.cpe_uri },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "package",
                    |m: &Vulnerability_Detail| { &m.package },
                    |m: &mut Vulnerability_Detail| { &mut m.package },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::package::Version>>(
                    "min_affected_version",
                    |m: &Vulnerability_Detail| { &m.min_affected_version },
                    |m: &mut Vulnerability_Detail| { &mut m.min_affected_version },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::package::Version>>(
                    "max_affected_version",
                    |m: &Vulnerability_Detail| { &m.max_affected_version },
                    |m: &mut Vulnerability_Detail| { &mut m.max_affected_version },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "severity_name",
                    |m: &Vulnerability_Detail| { &m.severity_name },
                    |m: &mut Vulnerability_Detail| { &mut m.severity_name },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "description",
                    |m: &Vulnerability_Detail| { &m.description },
                    |m: &mut Vulnerability_Detail| { &mut m.description },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<VulnerabilityLocation>>(
                    "fixed_location",
                    |m: &Vulnerability_Detail| { &m.fixed_location },
                    |m: &mut Vulnerability_Detail| { &mut m.fixed_location },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "package_type",
                    |m: &Vulnerability_Detail| { &m.package_type },
                    |m: &mut Vulnerability_Detail| { &mut m.package_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "is_obsolete",
                    |m: &Vulnerability_Detail| { &m.is_obsolete },
                    |m: &mut Vulnerability_Detail| { &mut m.is_obsolete },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Vulnerability_Detail>(
                    "Vulnerability_Detail",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Vulnerability_Detail {
        static mut instance: ::protobuf::lazy::Lazy<Vulnerability_Detail> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Vulnerability_Detail,
        };
        unsafe {
            instance.get(Vulnerability_Detail::new)
        }
    }
}

impl ::protobuf::Clear for Vulnerability_Detail {
    fn clear(&mut self) {
        self.cpe_uri.clear();
        self.package.clear();
        self.min_affected_version.clear();
        self.max_affected_version.clear();
        self.severity_name.clear();
        self.description.clear();
        self.fixed_location.clear();
        self.package_type.clear();
        self.is_obsolete = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Vulnerability_Detail {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Vulnerability_Detail {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Vulnerability_WindowsDetail {
    // message fields
    pub cpe_uri: ::std::string::String,
    pub name: ::std::string::String,
    pub description: ::std::string::String,
    pub fixing_kbs: ::protobuf::RepeatedField<Vulnerability_WindowsDetail_KnowledgeBase>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Vulnerability_WindowsDetail {
    fn default() -> &'a Vulnerability_WindowsDetail {
        <Vulnerability_WindowsDetail as ::protobuf::Message>::default_instance()
    }
}

impl Vulnerability_WindowsDetail {
    pub fn new() -> Vulnerability_WindowsDetail {
        ::std::default::Default::default()
    }

    // string cpe_uri = 1;


    pub fn get_cpe_uri(&self) -> &str {
        &self.cpe_uri
    }
    pub fn clear_cpe_uri(&mut self) {
        self.cpe_uri.clear();
    }

    // Param is passed by value, moved
    pub fn set_cpe_uri(&mut self, v: ::std::string::String) {
        self.cpe_uri = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cpe_uri(&mut self) -> &mut ::std::string::String {
        &mut self.cpe_uri
    }

    // Take field
    pub fn take_cpe_uri(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.cpe_uri, ::std::string::String::new())
    }

    // string name = 2;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string description = 3;


    pub fn get_description(&self) -> &str {
        &self.description
    }
    pub fn clear_description(&mut self) {
        self.description.clear();
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        &mut self.description
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.description, ::std::string::String::new())
    }

    // repeated .grafeas.v1beta1.vulnerability.Vulnerability.WindowsDetail.KnowledgeBase fixing_kbs = 4;


    pub fn get_fixing_kbs(&self) -> &[Vulnerability_WindowsDetail_KnowledgeBase] {
        &self.fixing_kbs
    }
    pub fn clear_fixing_kbs(&mut self) {
        self.fixing_kbs.clear();
    }

    // Param is passed by value, moved
    pub fn set_fixing_kbs(&mut self, v: ::protobuf::RepeatedField<Vulnerability_WindowsDetail_KnowledgeBase>) {
        self.fixing_kbs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_fixing_kbs(&mut self) -> &mut ::protobuf::RepeatedField<Vulnerability_WindowsDetail_KnowledgeBase> {
        &mut self.fixing_kbs
    }

    // Take field
    pub fn take_fixing_kbs(&mut self) -> ::protobuf::RepeatedField<Vulnerability_WindowsDetail_KnowledgeBase> {
        ::std::mem::replace(&mut self.fixing_kbs, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Vulnerability_WindowsDetail {
    fn is_initialized(&self) -> bool {
        for v in &self.fixing_kbs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.cpe_uri)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.description)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.fixing_kbs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.cpe_uri.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.cpe_uri);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.description);
        }
        for value in &self.fixing_kbs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.cpe_uri.is_empty() {
            os.write_string(1, &self.cpe_uri)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        if !self.description.is_empty() {
            os.write_string(3, &self.description)?;
        }
        for v in &self.fixing_kbs {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Vulnerability_WindowsDetail {
        Vulnerability_WindowsDetail::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "cpe_uri",
                    |m: &Vulnerability_WindowsDetail| { &m.cpe_uri },
                    |m: &mut Vulnerability_WindowsDetail| { &mut m.cpe_uri },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &Vulnerability_WindowsDetail| { &m.name },
                    |m: &mut Vulnerability_WindowsDetail| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "description",
                    |m: &Vulnerability_WindowsDetail| { &m.description },
                    |m: &mut Vulnerability_WindowsDetail| { &mut m.description },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Vulnerability_WindowsDetail_KnowledgeBase>>(
                    "fixing_kbs",
                    |m: &Vulnerability_WindowsDetail| { &m.fixing_kbs },
                    |m: &mut Vulnerability_WindowsDetail| { &mut m.fixing_kbs },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Vulnerability_WindowsDetail>(
                    "Vulnerability_WindowsDetail",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Vulnerability_WindowsDetail {
        static mut instance: ::protobuf::lazy::Lazy<Vulnerability_WindowsDetail> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Vulnerability_WindowsDetail,
        };
        unsafe {
            instance.get(Vulnerability_WindowsDetail::new)
        }
    }
}

impl ::protobuf::Clear for Vulnerability_WindowsDetail {
    fn clear(&mut self) {
        self.cpe_uri.clear();
        self.name.clear();
        self.description.clear();
        self.fixing_kbs.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Vulnerability_WindowsDetail {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Vulnerability_WindowsDetail {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Vulnerability_WindowsDetail_KnowledgeBase {
    // message fields
    pub name: ::std::string::String,
    pub url: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Vulnerability_WindowsDetail_KnowledgeBase {
    fn default() -> &'a Vulnerability_WindowsDetail_KnowledgeBase {
        <Vulnerability_WindowsDetail_KnowledgeBase as ::protobuf::Message>::default_instance()
    }
}

impl Vulnerability_WindowsDetail_KnowledgeBase {
    pub fn new() -> Vulnerability_WindowsDetail_KnowledgeBase {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string url = 2;


    pub fn get_url(&self) -> &str {
        &self.url
    }
    pub fn clear_url(&mut self) {
        self.url.clear();
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        &mut self.url
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.url, ::std::string::String::new())
    }
}

impl ::protobuf::Message for Vulnerability_WindowsDetail_KnowledgeBase {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.url)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.url.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.url);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.url.is_empty() {
            os.write_string(2, &self.url)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Vulnerability_WindowsDetail_KnowledgeBase {
        Vulnerability_WindowsDetail_KnowledgeBase::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &Vulnerability_WindowsDetail_KnowledgeBase| { &m.name },
                    |m: &mut Vulnerability_WindowsDetail_KnowledgeBase| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "url",
                    |m: &Vulnerability_WindowsDetail_KnowledgeBase| { &m.url },
                    |m: &mut Vulnerability_WindowsDetail_KnowledgeBase| { &mut m.url },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Vulnerability_WindowsDetail_KnowledgeBase>(
                    "Vulnerability_WindowsDetail_KnowledgeBase",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Vulnerability_WindowsDetail_KnowledgeBase {
        static mut instance: ::protobuf::lazy::Lazy<Vulnerability_WindowsDetail_KnowledgeBase> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Vulnerability_WindowsDetail_KnowledgeBase,
        };
        unsafe {
            instance.get(Vulnerability_WindowsDetail_KnowledgeBase::new)
        }
    }
}

impl ::protobuf::Clear for Vulnerability_WindowsDetail_KnowledgeBase {
    fn clear(&mut self) {
        self.name.clear();
        self.url.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Vulnerability_WindowsDetail_KnowledgeBase {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Vulnerability_WindowsDetail_KnowledgeBase {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Details {
    // message fields
    pub field_type: ::std::string::String,
    pub severity: Severity,
    pub cvss_score: f32,
    pub package_issue: ::protobuf::RepeatedField<PackageIssue>,
    pub short_description: ::std::string::String,
    pub long_description: ::std::string::String,
    pub related_urls: ::protobuf::RepeatedField<super::common::RelatedUrl>,
    pub effective_severity: Severity,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Details {
    fn default() -> &'a Details {
        <Details as ::protobuf::Message>::default_instance()
    }
}

impl Details {
    pub fn new() -> Details {
        ::std::default::Default::default()
    }

    // string type = 1;


    pub fn get_field_type(&self) -> &str {
        &self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ::std::string::String) {
        self.field_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_type(&mut self) -> &mut ::std::string::String {
        &mut self.field_type
    }

    // Take field
    pub fn take_field_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.field_type, ::std::string::String::new())
    }

    // .grafeas.v1beta1.vulnerability.Severity severity = 2;


    pub fn get_severity(&self) -> Severity {
        self.severity
    }
    pub fn clear_severity(&mut self) {
        self.severity = Severity::SEVERITY_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_severity(&mut self, v: Severity) {
        self.severity = v;
    }

    // float cvss_score = 3;


    pub fn get_cvss_score(&self) -> f32 {
        self.cvss_score
    }
    pub fn clear_cvss_score(&mut self) {
        self.cvss_score = 0.;
    }

    // Param is passed by value, moved
    pub fn set_cvss_score(&mut self, v: f32) {
        self.cvss_score = v;
    }

    // repeated .grafeas.v1beta1.vulnerability.PackageIssue package_issue = 4;


    pub fn get_package_issue(&self) -> &[PackageIssue] {
        &self.package_issue
    }
    pub fn clear_package_issue(&mut self) {
        self.package_issue.clear();
    }

    // Param is passed by value, moved
    pub fn set_package_issue(&mut self, v: ::protobuf::RepeatedField<PackageIssue>) {
        self.package_issue = v;
    }

    // Mutable pointer to the field.
    pub fn mut_package_issue(&mut self) -> &mut ::protobuf::RepeatedField<PackageIssue> {
        &mut self.package_issue
    }

    // Take field
    pub fn take_package_issue(&mut self) -> ::protobuf::RepeatedField<PackageIssue> {
        ::std::mem::replace(&mut self.package_issue, ::protobuf::RepeatedField::new())
    }

    // string short_description = 5;


    pub fn get_short_description(&self) -> &str {
        &self.short_description
    }
    pub fn clear_short_description(&mut self) {
        self.short_description.clear();
    }

    // Param is passed by value, moved
    pub fn set_short_description(&mut self, v: ::std::string::String) {
        self.short_description = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_short_description(&mut self) -> &mut ::std::string::String {
        &mut self.short_description
    }

    // Take field
    pub fn take_short_description(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.short_description, ::std::string::String::new())
    }

    // string long_description = 6;


    pub fn get_long_description(&self) -> &str {
        &self.long_description
    }
    pub fn clear_long_description(&mut self) {
        self.long_description.clear();
    }

    // Param is passed by value, moved
    pub fn set_long_description(&mut self, v: ::std::string::String) {
        self.long_description = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_long_description(&mut self) -> &mut ::std::string::String {
        &mut self.long_description
    }

    // Take field
    pub fn take_long_description(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.long_description, ::std::string::String::new())
    }

    // repeated .grafeas.v1beta1.RelatedUrl related_urls = 7;


    pub fn get_related_urls(&self) -> &[super::common::RelatedUrl] {
        &self.related_urls
    }
    pub fn clear_related_urls(&mut self) {
        self.related_urls.clear();
    }

    // Param is passed by value, moved
    pub fn set_related_urls(&mut self, v: ::protobuf::RepeatedField<super::common::RelatedUrl>) {
        self.related_urls = v;
    }

    // Mutable pointer to the field.
    pub fn mut_related_urls(&mut self) -> &mut ::protobuf::RepeatedField<super::common::RelatedUrl> {
        &mut self.related_urls
    }

    // Take field
    pub fn take_related_urls(&mut self) -> ::protobuf::RepeatedField<super::common::RelatedUrl> {
        ::std::mem::replace(&mut self.related_urls, ::protobuf::RepeatedField::new())
    }

    // .grafeas.v1beta1.vulnerability.Severity effective_severity = 8;


    pub fn get_effective_severity(&self) -> Severity {
        self.effective_severity
    }
    pub fn clear_effective_severity(&mut self) {
        self.effective_severity = Severity::SEVERITY_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_effective_severity(&mut self, v: Severity) {
        self.effective_severity = v;
    }
}

impl ::protobuf::Message for Details {
    fn is_initialized(&self) -> bool {
        for v in &self.package_issue {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.related_urls {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.field_type)?;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.severity, 2, &mut self.unknown_fields)?
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.cvss_score = tmp;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.package_issue)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.short_description)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.long_description)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.related_urls)?;
                },
                8 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.effective_severity, 8, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.field_type.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.field_type);
        }
        if self.severity != Severity::SEVERITY_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(2, self.severity);
        }
        if self.cvss_score != 0. {
            my_size += 5;
        }
        for value in &self.package_issue {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.short_description.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.short_description);
        }
        if !self.long_description.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.long_description);
        }
        for value in &self.related_urls {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.effective_severity != Severity::SEVERITY_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(8, self.effective_severity);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.field_type.is_empty() {
            os.write_string(1, &self.field_type)?;
        }
        if self.severity != Severity::SEVERITY_UNSPECIFIED {
            os.write_enum(2, self.severity.value())?;
        }
        if self.cvss_score != 0. {
            os.write_float(3, self.cvss_score)?;
        }
        for v in &self.package_issue {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.short_description.is_empty() {
            os.write_string(5, &self.short_description)?;
        }
        if !self.long_description.is_empty() {
            os.write_string(6, &self.long_description)?;
        }
        for v in &self.related_urls {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.effective_severity != Severity::SEVERITY_UNSPECIFIED {
            os.write_enum(8, self.effective_severity.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Details {
        Details::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "type",
                    |m: &Details| { &m.field_type },
                    |m: &mut Details| { &mut m.field_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Severity>>(
                    "severity",
                    |m: &Details| { &m.severity },
                    |m: &mut Details| { &mut m.severity },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "cvss_score",
                    |m: &Details| { &m.cvss_score },
                    |m: &mut Details| { &mut m.cvss_score },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PackageIssue>>(
                    "package_issue",
                    |m: &Details| { &m.package_issue },
                    |m: &mut Details| { &mut m.package_issue },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "short_description",
                    |m: &Details| { &m.short_description },
                    |m: &mut Details| { &mut m.short_description },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "long_description",
                    |m: &Details| { &m.long_description },
                    |m: &mut Details| { &mut m.long_description },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::common::RelatedUrl>>(
                    "related_urls",
                    |m: &Details| { &m.related_urls },
                    |m: &mut Details| { &mut m.related_urls },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Severity>>(
                    "effective_severity",
                    |m: &Details| { &m.effective_severity },
                    |m: &mut Details| { &mut m.effective_severity },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Details>(
                    "Details",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Details {
        static mut instance: ::protobuf::lazy::Lazy<Details> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Details,
        };
        unsafe {
            instance.get(Details::new)
        }
    }
}

impl ::protobuf::Clear for Details {
    fn clear(&mut self) {
        self.field_type.clear();
        self.severity = Severity::SEVERITY_UNSPECIFIED;
        self.cvss_score = 0.;
        self.package_issue.clear();
        self.short_description.clear();
        self.long_description.clear();
        self.related_urls.clear();
        self.effective_severity = Severity::SEVERITY_UNSPECIFIED;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Details {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Details {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PackageIssue {
    // message fields
    pub affected_location: ::protobuf::SingularPtrField<VulnerabilityLocation>,
    pub fixed_location: ::protobuf::SingularPtrField<VulnerabilityLocation>,
    pub severity_name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PackageIssue {
    fn default() -> &'a PackageIssue {
        <PackageIssue as ::protobuf::Message>::default_instance()
    }
}

impl PackageIssue {
    pub fn new() -> PackageIssue {
        ::std::default::Default::default()
    }

    // .grafeas.v1beta1.vulnerability.VulnerabilityLocation affected_location = 1;


    pub fn get_affected_location(&self) -> &VulnerabilityLocation {
        self.affected_location.as_ref().unwrap_or_else(|| VulnerabilityLocation::default_instance())
    }
    pub fn clear_affected_location(&mut self) {
        self.affected_location.clear();
    }

    pub fn has_affected_location(&self) -> bool {
        self.affected_location.is_some()
    }

    // Param is passed by value, moved
    pub fn set_affected_location(&mut self, v: VulnerabilityLocation) {
        self.affected_location = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_affected_location(&mut self) -> &mut VulnerabilityLocation {
        if self.affected_location.is_none() {
            self.affected_location.set_default();
        }
        self.affected_location.as_mut().unwrap()
    }

    // Take field
    pub fn take_affected_location(&mut self) -> VulnerabilityLocation {
        self.affected_location.take().unwrap_or_else(|| VulnerabilityLocation::new())
    }

    // .grafeas.v1beta1.vulnerability.VulnerabilityLocation fixed_location = 2;


    pub fn get_fixed_location(&self) -> &VulnerabilityLocation {
        self.fixed_location.as_ref().unwrap_or_else(|| VulnerabilityLocation::default_instance())
    }
    pub fn clear_fixed_location(&mut self) {
        self.fixed_location.clear();
    }

    pub fn has_fixed_location(&self) -> bool {
        self.fixed_location.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fixed_location(&mut self, v: VulnerabilityLocation) {
        self.fixed_location = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fixed_location(&mut self) -> &mut VulnerabilityLocation {
        if self.fixed_location.is_none() {
            self.fixed_location.set_default();
        }
        self.fixed_location.as_mut().unwrap()
    }

    // Take field
    pub fn take_fixed_location(&mut self) -> VulnerabilityLocation {
        self.fixed_location.take().unwrap_or_else(|| VulnerabilityLocation::new())
    }

    // string severity_name = 3;


    pub fn get_severity_name(&self) -> &str {
        &self.severity_name
    }
    pub fn clear_severity_name(&mut self) {
        self.severity_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_severity_name(&mut self, v: ::std::string::String) {
        self.severity_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_severity_name(&mut self) -> &mut ::std::string::String {
        &mut self.severity_name
    }

    // Take field
    pub fn take_severity_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.severity_name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for PackageIssue {
    fn is_initialized(&self) -> bool {
        for v in &self.affected_location {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.fixed_location {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.affected_location)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.fixed_location)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.severity_name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.affected_location.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.fixed_location.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.severity_name.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.severity_name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.affected_location.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.fixed_location.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.severity_name.is_empty() {
            os.write_string(3, &self.severity_name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PackageIssue {
        PackageIssue::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<VulnerabilityLocation>>(
                    "affected_location",
                    |m: &PackageIssue| { &m.affected_location },
                    |m: &mut PackageIssue| { &mut m.affected_location },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<VulnerabilityLocation>>(
                    "fixed_location",
                    |m: &PackageIssue| { &m.fixed_location },
                    |m: &mut PackageIssue| { &mut m.fixed_location },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "severity_name",
                    |m: &PackageIssue| { &m.severity_name },
                    |m: &mut PackageIssue| { &mut m.severity_name },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PackageIssue>(
                    "PackageIssue",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PackageIssue {
        static mut instance: ::protobuf::lazy::Lazy<PackageIssue> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PackageIssue,
        };
        unsafe {
            instance.get(PackageIssue::new)
        }
    }
}

impl ::protobuf::Clear for PackageIssue {
    fn clear(&mut self) {
        self.affected_location.clear();
        self.fixed_location.clear();
        self.severity_name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PackageIssue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PackageIssue {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VulnerabilityLocation {
    // message fields
    pub cpe_uri: ::std::string::String,
    pub package: ::std::string::String,
    pub version: ::protobuf::SingularPtrField<super::package::Version>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VulnerabilityLocation {
    fn default() -> &'a VulnerabilityLocation {
        <VulnerabilityLocation as ::protobuf::Message>::default_instance()
    }
}

impl VulnerabilityLocation {
    pub fn new() -> VulnerabilityLocation {
        ::std::default::Default::default()
    }

    // string cpe_uri = 1;


    pub fn get_cpe_uri(&self) -> &str {
        &self.cpe_uri
    }
    pub fn clear_cpe_uri(&mut self) {
        self.cpe_uri.clear();
    }

    // Param is passed by value, moved
    pub fn set_cpe_uri(&mut self, v: ::std::string::String) {
        self.cpe_uri = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cpe_uri(&mut self) -> &mut ::std::string::String {
        &mut self.cpe_uri
    }

    // Take field
    pub fn take_cpe_uri(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.cpe_uri, ::std::string::String::new())
    }

    // string package = 2;


    pub fn get_package(&self) -> &str {
        &self.package
    }
    pub fn clear_package(&mut self) {
        self.package.clear();
    }

    // Param is passed by value, moved
    pub fn set_package(&mut self, v: ::std::string::String) {
        self.package = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_package(&mut self) -> &mut ::std::string::String {
        &mut self.package
    }

    // Take field
    pub fn take_package(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.package, ::std::string::String::new())
    }

    // .grafeas.v1beta1.package.Version version = 3;


    pub fn get_version(&self) -> &super::package::Version {
        self.version.as_ref().unwrap_or_else(|| super::package::Version::default_instance())
    }
    pub fn clear_version(&mut self) {
        self.version.clear();
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: super::package::Version) {
        self.version = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version(&mut self) -> &mut super::package::Version {
        if self.version.is_none() {
            self.version.set_default();
        }
        self.version.as_mut().unwrap()
    }

    // Take field
    pub fn take_version(&mut self) -> super::package::Version {
        self.version.take().unwrap_or_else(|| super::package::Version::new())
    }
}

impl ::protobuf::Message for VulnerabilityLocation {
    fn is_initialized(&self) -> bool {
        for v in &self.version {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.cpe_uri)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.package)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.version)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.cpe_uri.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.cpe_uri);
        }
        if !self.package.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.package);
        }
        if let Some(ref v) = self.version.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.cpe_uri.is_empty() {
            os.write_string(1, &self.cpe_uri)?;
        }
        if !self.package.is_empty() {
            os.write_string(2, &self.package)?;
        }
        if let Some(ref v) = self.version.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VulnerabilityLocation {
        VulnerabilityLocation::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "cpe_uri",
                    |m: &VulnerabilityLocation| { &m.cpe_uri },
                    |m: &mut VulnerabilityLocation| { &mut m.cpe_uri },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "package",
                    |m: &VulnerabilityLocation| { &m.package },
                    |m: &mut VulnerabilityLocation| { &mut m.package },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::package::Version>>(
                    "version",
                    |m: &VulnerabilityLocation| { &m.version },
                    |m: &mut VulnerabilityLocation| { &mut m.version },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<VulnerabilityLocation>(
                    "VulnerabilityLocation",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static VulnerabilityLocation {
        static mut instance: ::protobuf::lazy::Lazy<VulnerabilityLocation> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const VulnerabilityLocation,
        };
        unsafe {
            instance.get(VulnerabilityLocation::new)
        }
    }
}

impl ::protobuf::Clear for VulnerabilityLocation {
    fn clear(&mut self) {
        self.cpe_uri.clear();
        self.package.clear();
        self.version.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VulnerabilityLocation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VulnerabilityLocation {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Severity {
    SEVERITY_UNSPECIFIED = 0,
    MINIMAL = 1,
    LOW = 2,
    MEDIUM = 3,
    HIGH = 4,
    CRITICAL = 5,
}

impl ::protobuf::ProtobufEnum for Severity {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Severity> {
        match value {
            0 => ::std::option::Option::Some(Severity::SEVERITY_UNSPECIFIED),
            1 => ::std::option::Option::Some(Severity::MINIMAL),
            2 => ::std::option::Option::Some(Severity::LOW),
            3 => ::std::option::Option::Some(Severity::MEDIUM),
            4 => ::std::option::Option::Some(Severity::HIGH),
            5 => ::std::option::Option::Some(Severity::CRITICAL),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Severity] = &[
            Severity::SEVERITY_UNSPECIFIED,
            Severity::MINIMAL,
            Severity::LOW,
            Severity::MEDIUM,
            Severity::HIGH,
            Severity::CRITICAL,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("Severity", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for Severity {
}

impl ::std::default::Default for Severity {
    fn default() -> Self {
        Severity::SEVERITY_UNSPECIFIED
    }
}

impl ::protobuf::reflect::ProtobufValue for Severity {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n!proto/v1beta1/vulnerability.proto\x12\x1dgrafeas.v1beta1.vulnerabilit\
    y\x1a\x1aproto/v1beta1/common.proto\x1a\x18proto/v1beta1/cvss.proto\x1a\
    \x1bproto/v1beta1/package.proto\"\xba\x08\n\rVulnerability\x12\x1d\n\ncv\
    ss_score\x18\x01\x20\x01(\x02R\tcvssScore\x12C\n\x08severity\x18\x02\x20\
    \x01(\x0e2'.grafeas.v1beta1.vulnerability.SeverityR\x08severity\x12M\n\
    \x07details\x18\x03\x20\x03(\x0b23.grafeas.v1beta1.vulnerability.Vulnera\
    bility.DetailR\x07details\x12>\n\x07cvss_v3\x18\x04\x20\x01(\x0b2%.grafe\
    as.v1beta1.vulnerability.CVSSv3R\x06cvssV3\x12c\n\x0fwindows_details\x18\
    \x05\x20\x03(\x0b2:.grafeas.v1beta1.vulnerability.Vulnerability.WindowsD\
    etailR\x0ewindowsDetails\x1a\xcf\x03\n\x06Detail\x12\x17\n\x07cpe_uri\
    \x18\x01\x20\x01(\tR\x06cpeUri\x12\x18\n\x07package\x18\x02\x20\x01(\tR\
    \x07package\x12R\n\x14min_affected_version\x18\x03\x20\x01(\x0b2\x20.gra\
    feas.v1beta1.package.VersionR\x12minAffectedVersion\x12V\n\x14max_affect\
    ed_version\x18\x04\x20\x01(\x0b2\x20.grafeas.v1beta1.package.VersionR\
    \x12maxAffectedVersionB\x02\x18\x01\x12#\n\rseverity_name\x18\x05\x20\
    \x01(\tR\x0cseverityName\x12\x20\n\x0bdescription\x18\x06\x20\x01(\tR\
    \x0bdescription\x12[\n\x0efixed_location\x18\x07\x20\x01(\x0b24.grafeas.\
    v1beta1.vulnerability.VulnerabilityLocationR\rfixedLocation\x12!\n\x0cpa\
    ckage_type\x18\x08\x20\x01(\tR\x0bpackageType\x12\x1f\n\x0bis_obsolete\
    \x18\t\x20\x01(\x08R\nisObsolete\x1a\xfe\x01\n\rWindowsDetail\x12\x17\n\
    \x07cpe_uri\x18\x01\x20\x01(\tR\x06cpeUri\x12\x12\n\x04name\x18\x02\x20\
    \x01(\tR\x04name\x12\x20\n\x0bdescription\x18\x03\x20\x01(\tR\x0bdescrip\
    tion\x12g\n\nfixing_kbs\x18\x04\x20\x03(\x0b2H.grafeas.v1beta1.vulnerabi\
    lity.Vulnerability.WindowsDetail.KnowledgeBaseR\tfixingKbs\x1a5\n\rKnowl\
    edgeBase\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12\x10\n\x03url\
    \x18\x02\x20\x01(\tR\x03url\"\xc3\x03\n\x07Details\x12\x12\n\x04type\x18\
    \x01\x20\x01(\tR\x04type\x12C\n\x08severity\x18\x02\x20\x01(\x0e2'.grafe\
    as.v1beta1.vulnerability.SeverityR\x08severity\x12\x1d\n\ncvss_score\x18\
    \x03\x20\x01(\x02R\tcvssScore\x12P\n\rpackage_issue\x18\x04\x20\x03(\x0b\
    2+.grafeas.v1beta1.vulnerability.PackageIssueR\x0cpackageIssue\x12+\n\
    \x11short_description\x18\x05\x20\x01(\tR\x10shortDescription\x12)\n\x10\
    long_description\x18\x06\x20\x01(\tR\x0flongDescription\x12>\n\x0crelate\
    d_urls\x18\x07\x20\x03(\x0b2\x1b.grafeas.v1beta1.RelatedUrlR\x0brelatedU\
    rls\x12V\n\x12effective_severity\x18\x08\x20\x01(\x0e2'.grafeas.v1beta1.\
    vulnerability.SeverityR\x11effectiveSeverity\"\xf3\x01\n\x0cPackageIssue\
    \x12a\n\x11affected_location\x18\x01\x20\x01(\x0b24.grafeas.v1beta1.vuln\
    erability.VulnerabilityLocationR\x10affectedLocation\x12[\n\x0efixed_loc\
    ation\x18\x02\x20\x01(\x0b24.grafeas.v1beta1.vulnerability.Vulnerability\
    LocationR\rfixedLocation\x12#\n\rseverity_name\x18\x03\x20\x01(\tR\x0cse\
    verityName\"\x86\x01\n\x15VulnerabilityLocation\x12\x17\n\x07cpe_uri\x18\
    \x01\x20\x01(\tR\x06cpeUri\x12\x18\n\x07package\x18\x02\x20\x01(\tR\x07p\
    ackage\x12:\n\x07version\x18\x03\x20\x01(\x0b2\x20.grafeas.v1beta1.packa\
    ge.VersionR\x07version*^\n\x08Severity\x12\x18\n\x14SEVERITY_UNSPECIFIED\
    \x10\0\x12\x0b\n\x07MINIMAL\x10\x01\x12\x07\n\x03LOW\x10\x02\x12\n\n\x06\
    MEDIUM\x10\x03\x12\x08\n\x04HIGH\x10\x04\x12\x0c\n\x08CRITICAL\x10\x05Bk\
    \n\x20io.grafeas.v1beta1.vulnerabilityP\x01Z?github.com/grafeas/grafeas/\
    proto/v1beta1/vulnerability_go_proto\xa2\x02\x03GRAJ\x82=\n\x07\x12\x05\
    \x0e\0\xc3\x01\x01\n\xda\x04\n\x01\x0c\x12\x03\x0e\0\x122\xcf\x04\x20Cop\
    yright\x202018\x20The\x20Grafeas\x20Authors.\x20All\x20rights\x20reserve\
    d.\n\n\x20Licensed\x20under\x20the\x20Apache\x20License,\x20Version\x202\
    .0\x20(the\x20\"License\");\n\x20you\x20may\x20not\x20use\x20this\x20fil\
    e\x20except\x20in\x20compliance\x20with\x20the\x20License.\n\x20You\x20m\
    ay\x20obtain\x20a\x20copy\x20of\x20the\x20License\x20at\n\n\x20\x20\x20\
    \x20http://www.apache.org/licenses/LICENSE-2.0\n\n\x20Unless\x20required\
    \x20by\x20applicable\x20law\x20or\x20agreed\x20to\x20in\x20writing,\x20s\
    oftware\n\x20distributed\x20under\x20the\x20License\x20is\x20distributed\
    \x20on\x20an\x20\"AS\x20IS\"\x20BASIS,\n\x20WITHOUT\x20WARRANTIES\x20OR\
    \x20CONDITIONS\x20OF\x20ANY\x20KIND,\x20either\x20express\x20or\x20impli\
    ed.\n\x20See\x20the\x20License\x20for\x20the\x20specific\x20language\x20\
    governing\x20permissions\x20and\n\x20limitations\x20under\x20the\x20Lice\
    nse.\n\n\x08\n\x01\x02\x12\x03\x10\0&\n\x08\n\x01\x08\x12\x03\x12\0V\n\t\
    \n\x02\x08\x0b\x12\x03\x12\0V\n\x08\n\x01\x08\x12\x03\x13\0\"\n\t\n\x02\
    \x08\n\x12\x03\x13\0\"\n\x08\n\x01\x08\x12\x03\x14\09\n\t\n\x02\x08\x01\
    \x12\x03\x14\09\n\x08\n\x01\x08\x12\x03\x15\0!\n\t\n\x02\x08$\x12\x03\
    \x15\0!\n\t\n\x02\x03\0\x12\x03\x17\0$\n\t\n\x02\x03\x01\x12\x03\x18\0\"\
    \n\t\n\x02\x03\x02\x12\x03\x19\0%\n=\n\x02\x05\0\x12\x04\x1c\0)\x01\x1a1\
    \x20Note\x20provider-assigned\x20severity/impact\x20ranking.\n\n\n\n\x03\
    \x05\0\x01\x12\x03\x1c\x05\r\n\x17\n\x04\x05\0\x02\0\x12\x03\x1e\x02\x1b\
    \x1a\n\x20Unknown.\n\n\x0c\n\x05\x05\0\x02\0\x01\x12\x03\x1e\x02\x16\n\
    \x0c\n\x05\x05\0\x02\0\x02\x12\x03\x1e\x19\x1a\n\x20\n\x04\x05\0\x02\x01\
    \x12\x03\x20\x02\x0e\x1a\x13\x20Minimal\x20severity.\n\n\x0c\n\x05\x05\0\
    \x02\x01\x01\x12\x03\x20\x02\t\n\x0c\n\x05\x05\0\x02\x01\x02\x12\x03\x20\
    \x0c\r\n\x1c\n\x04\x05\0\x02\x02\x12\x03\"\x02\n\x1a\x0f\x20Low\x20sever\
    ity.\n\n\x0c\n\x05\x05\0\x02\x02\x01\x12\x03\"\x02\x05\n\x0c\n\x05\x05\0\
    \x02\x02\x02\x12\x03\"\x08\t\n\x1f\n\x04\x05\0\x02\x03\x12\x03$\x02\r\
    \x1a\x12\x20Medium\x20severity.\n\n\x0c\n\x05\x05\0\x02\x03\x01\x12\x03$\
    \x02\x08\n\x0c\n\x05\x05\0\x02\x03\x02\x12\x03$\x0b\x0c\n\x1d\n\x04\x05\
    \0\x02\x04\x12\x03&\x02\x0b\x1a\x10\x20High\x20severity.\n\n\x0c\n\x05\
    \x05\0\x02\x04\x01\x12\x03&\x02\x06\n\x0c\n\x05\x05\0\x02\x04\x02\x12\
    \x03&\t\n\n!\n\x04\x05\0\x02\x05\x12\x03(\x02\x0f\x1a\x14\x20Critical\
    \x20severity.\n\n\x0c\n\x05\x05\0\x02\x05\x01\x12\x03(\x02\n\n\x0c\n\x05\
    \x05\0\x02\x05\x02\x12\x03(\r\x0e\nX\n\x02\x04\0\x12\x05,\0\x87\x01\x01\
    \x1aK\x20Vulnerability\x20provides\x20metadata\x20about\x20a\x20security\
    \x20vulnerability\x20in\x20a\x20Note.\n\n\n\n\x03\x04\0\x01\x12\x03,\x08\
    \x15\n5\n\x04\x04\0\x02\0\x12\x03.\x02\x17\x1a(\x20The\x20CVSS\x20score\
    \x20for\x20this\x20vulnerability.\n\n\r\n\x05\x04\0\x02\0\x04\x12\x04.\
    \x02,\x17\n\x0c\n\x05\x04\0\x02\0\x05\x12\x03.\x02\x07\n\x0c\n\x05\x04\0\
    \x02\0\x01\x12\x03.\x08\x12\n\x0c\n\x05\x04\0\x02\0\x03\x12\x03.\x15\x16\
    \nB\n\x04\x04\0\x02\x01\x12\x031\x02\x18\x1a5\x20Note\x20provider\x20ass\
    igned\x20impact\x20of\x20the\x20vulnerability.\n\n\r\n\x05\x04\0\x02\x01\
    \x04\x12\x041\x02.\x17\n\x0c\n\x05\x04\0\x02\x01\x06\x12\x031\x02\n\n\
    \x0c\n\x05\x04\0\x02\x01\x01\x12\x031\x0b\x13\n\x0c\n\x05\x04\0\x02\x01\
    \x03\x12\x031\x16\x17\n\xb7\x01\n\x04\x04\0\x02\x02\x12\x036\x02\x1e\x1a\
    \xa9\x01\x20All\x20information\x20about\x20the\x20package\x20to\x20speci\
    fically\x20identify\x20this\n\x20vulnerability.\x20One\x20entry\x20per\
    \x20(version\x20range\x20and\x20cpe_uri)\x20the\x20package\n\x20vulnerab\
    ility\x20has\x20manifested\x20in.\n\n\x0c\n\x05\x04\0\x02\x02\x04\x12\
    \x036\x02\n\n\x0c\n\x05\x04\0\x02\x02\x06\x12\x036\x0b\x11\n\x0c\n\x05\
    \x04\0\x02\x02\x01\x12\x036\x12\x19\n\x0c\n\x05\x04\0\x02\x02\x03\x12\
    \x036\x1c\x1d\n\xbc\x01\n\x04\x04\0\x03\0\x12\x04;\x02_\x03\x1a\xad\x01\
    \x20Identifies\x20all\x20appearances\x20of\x20this\x20vulnerability\x20i\
    n\x20the\x20package\x20for\x20a\n\x20specific\x20distro/location.\x20For\
    \x20example:\x20glibc\x20in\n\x20cpe:/o:debian:debian_linux:8\x20for\x20\
    versions\x202.1\x20-\x202.2\n\n\x0c\n\x05\x04\0\x03\0\x01\x12\x03;\n\x10\
    \n\xc6\x01\n\x06\x04\0\x03\0\x02\0\x12\x03@\x04\x17\x1a\xb6\x01\x20Requi\
    red.\x20The\x20CPE\x20URI\x20in\n\x20[cpe\x20format](https://cpe.mitre.o\
    rg/specification/)\x20in\x20which\x20the\n\x20vulnerability\x20manifests\
    .\x20Examples\x20include\x20distro\x20or\x20storage\x20location\x20for\n\
    \x20vulnerable\x20jar.\n\n\x0f\n\x07\x04\0\x03\0\x02\0\x04\x12\x04@\x04;\
    \x12\n\x0e\n\x07\x04\0\x03\0\x02\0\x05\x12\x03@\x04\n\n\x0e\n\x07\x04\0\
    \x03\0\x02\0\x01\x12\x03@\x0b\x12\n\x0e\n\x07\x04\0\x03\0\x02\0\x03\x12\
    \x03@\x15\x16\nU\n\x06\x04\0\x03\0\x02\x01\x12\x03C\x04\x17\x1aF\x20Requ\
    ired.\x20The\x20name\x20of\x20the\x20package\x20where\x20the\x20vulnerab\
    ility\x20was\x20found.\n\n\x0f\n\x07\x04\0\x03\0\x02\x01\x04\x12\x04C\
    \x04@\x17\n\x0e\n\x07\x04\0\x03\0\x02\x01\x05\x12\x03C\x04\n\n\x0e\n\x07\
    \x04\0\x03\0\x02\x01\x01\x12\x03C\x0b\x12\n\x0e\n\x07\x04\0\x03\0\x02\
    \x01\x03\x12\x03C\x15\x16\nR\n\x06\x04\0\x03\0\x02\x02\x12\x03F\x04=\x1a\
    C\x20The\x20min\x20version\x20of\x20the\x20package\x20in\x20which\x20the\
    \x20vulnerability\x20exists.\n\n\x0f\n\x07\x04\0\x03\0\x02\x02\x04\x12\
    \x04F\x04C\x17\n\x0e\n\x07\x04\0\x03\0\x02\x02\x06\x12\x03F\x04#\n\x0e\n\
    \x07\x04\0\x03\0\x02\x02\x01\x12\x03F$8\n\x0e\n\x07\x04\0\x03\0\x02\x02\
    \x03\x12\x03F;<\n\x89\x01\n\x06\x04\0\x03\0\x02\x03\x12\x04K\x04M\x06\
    \x1ay\x20Deprecated,\x20do\x20not\x20use.\x20Use\x20fixed_location\x20in\
    stead.\n\n\x20The\x20max\x20version\x20of\x20the\x20package\x20in\x20whi\
    ch\x20the\x20vulnerability\x20exists.\n\n\x0f\n\x07\x04\0\x03\0\x02\x03\
    \x04\x12\x04K\x04F=\n\x0e\n\x07\x04\0\x03\0\x02\x03\x06\x12\x03K\x04#\n\
    \x0e\n\x07\x04\0\x03\0\x02\x03\x01\x12\x03K$8\n\x0e\n\x07\x04\0\x03\0\
    \x02\x03\x03\x12\x03K;<\n\x0f\n\x07\x04\0\x03\0\x02\x03\x08\x12\x04K=M\
    \x05\n\x0f\n\x08\x04\0\x03\0\x02\x03\x08\x03\x12\x03L\x06\x17\nT\n\x06\
    \x04\0\x03\0\x02\x04\x12\x03P\x04\x1d\x1aE\x20The\x20severity\x20(eg:\
    \x20distro\x20assigned\x20severity)\x20for\x20this\x20vulnerability.\n\n\
    \x0f\n\x07\x04\0\x03\0\x02\x04\x04\x12\x04P\x04M\x06\n\x0e\n\x07\x04\0\
    \x03\0\x02\x04\x05\x12\x03P\x04\n\n\x0e\n\x07\x04\0\x03\0\x02\x04\x01\
    \x12\x03P\x0b\x18\n\x0e\n\x07\x04\0\x03\0\x02\x04\x03\x12\x03P\x1b\x1c\n\
    <\n\x06\x04\0\x03\0\x02\x05\x12\x03S\x04\x1b\x1a-\x20A\x20vendor-specifi\
    c\x20description\x20of\x20this\x20note.\n\n\x0f\n\x07\x04\0\x03\0\x02\
    \x05\x04\x12\x04S\x04P\x1d\n\x0e\n\x07\x04\0\x03\0\x02\x05\x05\x12\x03S\
    \x04\n\n\x0e\n\x07\x04\0\x03\0\x02\x05\x01\x12\x03S\x0b\x16\n\x0e\n\x07\
    \x04\0\x03\0\x02\x05\x03\x12\x03S\x19\x1a\n;\n\x06\x04\0\x03\0\x02\x06\
    \x12\x03V\x04-\x1a,\x20The\x20fix\x20for\x20this\x20specific\x20package\
    \x20version.\n\n\x0f\n\x07\x04\0\x03\0\x02\x06\x04\x12\x04V\x04S\x1b\n\
    \x0e\n\x07\x04\0\x03\0\x02\x06\x06\x12\x03V\x04\x19\n\x0e\n\x07\x04\0\
    \x03\0\x02\x06\x01\x12\x03V\x1a(\n\x0e\n\x07\x04\0\x03\0\x02\x06\x03\x12\
    \x03V+,\ne\n\x06\x04\0\x03\0\x02\x07\x12\x03Z\x04\x1c\x1aV\x20The\x20typ\
    e\x20of\x20package;\x20whether\x20native\x20or\x20non\x20native(ruby\x20\
    gems,\x20node.js\n\x20packages\x20etc).\n\n\x0f\n\x07\x04\0\x03\0\x02\
    \x07\x04\x12\x04Z\x04V-\n\x0e\n\x07\x04\0\x03\0\x02\x07\x05\x12\x03Z\x04\
    \n\n\x0e\n\x07\x04\0\x03\0\x02\x07\x01\x12\x03Z\x0b\x17\n\x0e\n\x07\x04\
    \0\x03\0\x02\x07\x03\x12\x03Z\x1a\x1b\nm\n\x06\x04\0\x03\0\x02\x08\x12\
    \x03^\x04\x19\x1a^\x20Whether\x20this\x20detail\x20is\x20obsolete.\x20Oc\
    currences\x20are\x20expected\x20not\x20to\x20point\x20to\n\x20obsolete\
    \x20details.\n\n\x0f\n\x07\x04\0\x03\0\x02\x08\x04\x12\x04^\x04Z\x1c\n\
    \x0e\n\x07\x04\0\x03\0\x02\x08\x05\x12\x03^\x04\x08\n\x0e\n\x07\x04\0\
    \x03\0\x02\x08\x01\x12\x03^\t\x14\n\x0e\n\x07\x04\0\x03\0\x02\x08\x03\
    \x12\x03^\x17\x18\n2\n\x04\x04\0\x02\x03\x12\x03b\x02\x15\x1a%\x20The\
    \x20full\x20description\x20of\x20the\x20CVSSv3.\n\n\r\n\x05\x04\0\x02\
    \x03\x04\x12\x04b\x02_\x03\n\x0c\n\x05\x04\0\x02\x03\x06\x12\x03b\x02\
    \x08\n\x0c\n\x05\x04\0\x02\x03\x01\x12\x03b\t\x10\n\x0c\n\x05\x04\0\x02\
    \x03\x03\x12\x03b\x13\x14\n\x9f\x02\n\x04\x04\0\x02\x04\x12\x03h\x02-\
    \x1a\x91\x02\x20Windows\x20details\x20get\x20their\x20own\x20format\x20b\
    ecause\x20the\x20information\x20format\x20and\n\x20model\x20don't\x20mat\
    ch\x20a\x20normal\x20detail.\x20Specifically\x20Windows\x20updates\x20ar\
    e\x20done\x20as\n\x20patches,\x20thus\x20Windows\x20vulnerabilities\x20r\
    eally\x20are\x20a\x20missing\x20package,\x20rather\n\x20than\x20a\x20pac\
    kage\x20being\x20at\x20an\x20incorrect\x20version.\n\n\x0c\n\x05\x04\0\
    \x02\x04\x04\x12\x03h\x02\n\n\x0c\n\x05\x04\0\x02\x04\x06\x12\x03h\x0b\
    \x18\n\x0c\n\x05\x04\0\x02\x04\x01\x12\x03h\x19(\n\x0c\n\x05\x04\0\x02\
    \x04\x03\x12\x03h+,\n\r\n\x04\x04\0\x03\x01\x12\x05j\x02\x84\x01\x03\n\
    \x0c\n\x05\x04\0\x03\x01\x01\x12\x03j\n\x17\n\xc6\x01\n\x06\x04\0\x03\
    \x01\x02\0\x12\x03o\x04\x17\x1a\xb6\x01\x20Required.\x20The\x20CPE\x20UR\
    I\x20in\n\x20[cpe\x20format](https://cpe.mitre.org/specification/)\x20in\
    \x20which\x20the\n\x20vulnerability\x20manifests.\x20Examples\x20include\
    \x20distro\x20or\x20storage\x20location\x20for\n\x20vulnerable\x20jar.\n\
    \n\x0f\n\x07\x04\0\x03\x01\x02\0\x04\x12\x04o\x04j\x19\n\x0e\n\x07\x04\0\
    \x03\x01\x02\0\x05\x12\x03o\x04\n\n\x0e\n\x07\x04\0\x03\x01\x02\0\x01\
    \x12\x03o\x0b\x12\n\x0e\n\x07\x04\0\x03\x01\x02\0\x03\x12\x03o\x15\x16\n\
    9\n\x06\x04\0\x03\x01\x02\x01\x12\x03r\x04\x14\x1a*\x20Required.\x20The\
    \x20name\x20of\x20the\x20vulnerability.\n\n\x0f\n\x07\x04\0\x03\x01\x02\
    \x01\x04\x12\x04r\x04o\x17\n\x0e\n\x07\x04\0\x03\x01\x02\x01\x05\x12\x03\
    r\x04\n\n\x0e\n\x07\x04\0\x03\x01\x02\x01\x01\x12\x03r\x0b\x0f\n\x0e\n\
    \x07\x04\0\x03\x01\x02\x01\x03\x12\x03r\x12\x13\n6\n\x06\x04\0\x03\x01\
    \x02\x02\x12\x03u\x04\x1b\x1a'\x20The\x20description\x20of\x20the\x20vul\
    nerability.\n\n\x0f\n\x07\x04\0\x03\x01\x02\x02\x04\x12\x04u\x04r\x14\n\
    \x0e\n\x07\x04\0\x03\x01\x02\x02\x05\x12\x03u\x04\n\n\x0e\n\x07\x04\0\
    \x03\x01\x02\x02\x01\x12\x03u\x0b\x16\n\x0e\n\x07\x04\0\x03\x01\x02\x02\
    \x03\x12\x03u\x19\x1a\n\x85\x02\n\x06\x04\0\x03\x01\x02\x03\x12\x03{\x04\
    *\x1a\xf5\x01\x20Required.\x20The\x20names\x20of\x20the\x20KBs\x20which\
    \x20have\x20hotfixes\x20to\x20mitigate\x20this\n\x20vulnerability.\x20No\
    te\x20that\x20there\x20may\x20be\x20multiple\x20hotfixes\x20(and\x20thus\
    \n\x20multiple\x20KBs)\x20that\x20mitigate\x20a\x20given\x20vulnerabilit\
    y.\x20Currently\x20any\x20listed\n\x20kb's\x20presence\x20is\x20consider\
    ed\x20a\x20fix.\n\n\x0e\n\x07\x04\0\x03\x01\x02\x03\x04\x12\x03{\x04\x0c\
    \n\x0e\n\x07\x04\0\x03\x01\x02\x03\x06\x12\x03{\r\x1a\n\x0e\n\x07\x04\0\
    \x03\x01\x02\x03\x01\x12\x03{\x1b%\n\x0e\n\x07\x04\0\x03\x01\x02\x03\x03\
    \x12\x03{()\n\x0f\n\x06\x04\0\x03\x01\x03\0\x12\x05}\x04\x83\x01\x05\n\
    \x0e\n\x07\x04\0\x03\x01\x03\0\x01\x12\x03}\x0c\x19\nN\n\x08\x04\0\x03\
    \x01\x03\0\x02\0\x12\x03\x7f\x06\x16\x1a=\x20The\x20KB\x20name\x20(gener\
    ally\x20of\x20the\x20form\x20KB[0-9]+\x20i.e.\x20KB123456).\n\n\x11\n\t\
    \x04\0\x03\x01\x03\0\x02\0\x04\x12\x04\x7f\x06}\x1b\n\x10\n\t\x04\0\x03\
    \x01\x03\0\x02\0\x05\x12\x03\x7f\x06\x0c\n\x10\n\t\x04\0\x03\x01\x03\0\
    \x02\0\x01\x12\x03\x7f\r\x11\n\x10\n\t\x04\0\x03\x01\x03\0\x02\0\x03\x12\
    \x03\x7f\x14\x15\no\n\x08\x04\0\x03\x01\x03\0\x02\x01\x12\x04\x82\x01\
    \x06\x15\x1a]\x20A\x20link\x20to\x20the\x20KB\x20in\x20the\x20Windows\
    \x20update\x20catalog\x20-\n\x20https://www.catalog.update.microsoft.com\
    /\n\n\x12\n\t\x04\0\x03\x01\x03\0\x02\x01\x04\x12\x05\x82\x01\x06\x7f\
    \x16\n\x11\n\t\x04\0\x03\x01\x03\0\x02\x01\x05\x12\x04\x82\x01\x06\x0c\n\
    \x11\n\t\x04\0\x03\x01\x03\0\x02\x01\x01\x12\x04\x82\x01\r\x10\n\x11\n\t\
    \x04\0\x03\x01\x03\0\x02\x01\x03\x12\x04\x82\x01\x13\x14\n6\n\x02\x04\
    \x01\x12\x06\x8a\x01\0\xa8\x01\x01\x1a(\x20Details\x20of\x20a\x20vulnera\
    bility\x20Occurrence.\n\n\x0b\n\x03\x04\x01\x01\x12\x04\x8a\x01\x08\x0f\
    \nc\n\x04\x04\x01\x02\0\x12\x04\x8d\x01\x02\x12\x1aU\x20The\x20type\x20o\
    f\x20package;\x20whether\x20native\x20or\x20non\x20native(ruby\x20gems,\
    \x20node.js\n\x20packages\x20etc)\n\n\x0f\n\x05\x04\x01\x02\0\x04\x12\
    \x06\x8d\x01\x02\x8a\x01\x11\n\r\n\x05\x04\x01\x02\0\x05\x12\x04\x8d\x01\
    \x02\x08\n\r\n\x05\x04\x01\x02\0\x01\x12\x04\x8d\x01\t\r\n\r\n\x05\x04\
    \x01\x02\0\x03\x12\x04\x8d\x01\x10\x11\nV\n\x04\x04\x01\x02\x01\x12\x04\
    \x90\x01\x02\x18\x1aH\x20Output\x20only.\x20The\x20note\x20provider\x20a\
    ssigned\x20Severity\x20of\x20the\x20vulnerability.\n\n\x0f\n\x05\x04\x01\
    \x02\x01\x04\x12\x06\x90\x01\x02\x8d\x01\x12\n\r\n\x05\x04\x01\x02\x01\
    \x06\x12\x04\x90\x01\x02\n\n\r\n\x05\x04\x01\x02\x01\x01\x12\x04\x90\x01\
    \x0b\x13\n\r\n\x05\x04\x01\x02\x01\x03\x12\x04\x90\x01\x16\x17\n\xa5\x01\
    \n\x04\x04\x01\x02\x02\x12\x04\x95\x01\x02\x17\x1a\x96\x01\x20Output\x20\
    only.\x20The\x20CVSS\x20score\x20of\x20this\x20vulnerability.\x20CVSS\
    \x20score\x20is\x20on\x20a\n\x20scale\x20of\x200-10\x20where\x200\x20ind\
    icates\x20low\x20severity\x20and\x2010\x20indicates\x20high\n\x20severit\
    y.\n\n\x0f\n\x05\x04\x01\x02\x02\x04\x12\x06\x95\x01\x02\x90\x01\x18\n\r\
    \n\x05\x04\x01\x02\x02\x05\x12\x04\x95\x01\x02\x07\n\r\n\x05\x04\x01\x02\
    \x02\x01\x12\x04\x95\x01\x08\x12\n\r\n\x05\x04\x01\x02\x02\x03\x12\x04\
    \x95\x01\x15\x16\nw\n\x04\x04\x01\x02\x03\x12\x04\x99\x01\x02*\x1ai\x20R\
    equired.\x20The\x20set\x20of\x20affected\x20locations\x20and\x20their\
    \x20fixes\x20(if\x20available)\n\x20within\x20the\x20associated\x20resou\
    rce.\n\n\r\n\x05\x04\x01\x02\x03\x04\x12\x04\x99\x01\x02\n\n\r\n\x05\x04\
    \x01\x02\x03\x06\x12\x04\x99\x01\x0b\x17\n\r\n\x05\x04\x01\x02\x03\x01\
    \x12\x04\x99\x01\x18%\n\r\n\x05\x04\x01\x02\x03\x03\x12\x04\x99\x01()\nN\
    \n\x04\x04\x01\x02\x04\x12\x04\x9c\x01\x02\x1f\x1a@\x20Output\x20only.\
    \x20A\x20one\x20sentence\x20description\x20of\x20this\x20vulnerability.\
    \n\n\x0f\n\x05\x04\x01\x02\x04\x04\x12\x06\x9c\x01\x02\x99\x01*\n\r\n\
    \x05\x04\x01\x02\x04\x05\x12\x04\x9c\x01\x02\x08\n\r\n\x05\x04\x01\x02\
    \x04\x01\x12\x04\x9c\x01\t\x1a\n\r\n\x05\x04\x01\x02\x04\x03\x12\x04\x9c\
    \x01\x1d\x1e\nJ\n\x04\x04\x01\x02\x05\x12\x04\x9f\x01\x02\x1e\x1a<\x20Ou\
    tput\x20only.\x20A\x20detailed\x20description\x20of\x20this\x20vulnerabi\
    lity.\n\n\x0f\n\x05\x04\x01\x02\x05\x04\x12\x06\x9f\x01\x02\x9c\x01\x1f\
    \n\r\n\x05\x04\x01\x02\x05\x05\x12\x04\x9f\x01\x02\x08\n\r\n\x05\x04\x01\
    \x02\x05\x01\x12\x04\x9f\x01\t\x19\n\r\n\x05\x04\x01\x02\x05\x03\x12\x04\
    \x9f\x01\x1c\x1d\n@\n\x04\x04\x01\x02\x06\x12\x04\xa2\x01\x027\x1a2\x20O\
    utput\x20only.\x20URLs\x20related\x20to\x20this\x20vulnerability.\n\n\r\
    \n\x05\x04\x01\x02\x06\x04\x12\x04\xa2\x01\x02\n\n\r\n\x05\x04\x01\x02\
    \x06\x06\x12\x04\xa2\x01\x0b%\n\r\n\x05\x04\x01\x02\x06\x01\x12\x04\xa2\
    \x01&2\n\r\n\x05\x04\x01\x02\x06\x03\x12\x04\xa2\x0156\n\xc4\x01\n\x04\
    \x04\x01\x02\x07\x12\x04\xa7\x01\x02\"\x1a\xb5\x01\x20The\x20distro\x20a\
    ssigned\x20severity\x20for\x20this\x20vulnerability\x20when\x20it\x20is\
    \n\x20available,\x20and\x20note\x20provider\x20assigned\x20severity\x20w\
    hen\x20distro\x20has\x20not\x20yet\n\x20assigned\x20a\x20severity\x20for\
    \x20this\x20vulnerability.\n\n\x0f\n\x05\x04\x01\x02\x07\x04\x12\x06\xa7\
    \x01\x02\xa2\x017\n\r\n\x05\x04\x01\x02\x07\x06\x12\x04\xa7\x01\x02\n\n\
    \r\n\x05\x04\x01\x02\x07\x01\x12\x04\xa7\x01\x0b\x1d\n\r\n\x05\x04\x01\
    \x02\x07\x03\x12\x04\xa7\x01\x20!\nx\n\x02\x04\x02\x12\x06\xac\x01\0\xb6\
    \x01\x01\x1aj\x20This\x20message\x20wraps\x20a\x20location\x20affected\
    \x20by\x20a\x20vulnerability\x20and\x20its\n\x20associated\x20fix\x20(if\
    \x20one\x20is\x20available).\n\n\x0b\n\x03\x04\x02\x01\x12\x04\xac\x01\
    \x08\x14\n<\n\x04\x04\x02\x02\0\x12\x04\xae\x01\x02.\x1a.\x20Required.\
    \x20The\x20location\x20of\x20the\x20vulnerability.\n\n\x0f\n\x05\x04\x02\
    \x02\0\x04\x12\x06\xae\x01\x02\xac\x01\x16\n\r\n\x05\x04\x02\x02\0\x06\
    \x12\x04\xae\x01\x02\x17\n\r\n\x05\x04\x02\x02\0\x01\x12\x04\xae\x01\x18\
    )\n\r\n\x05\x04\x02\x02\0\x03\x12\x04\xae\x01,-\nD\n\x04\x04\x02\x02\x01\
    \x12\x04\xb1\x01\x02+\x1a6\x20The\x20location\x20of\x20the\x20available\
    \x20fix\x20for\x20vulnerability.\n\n\x0f\n\x05\x04\x02\x02\x01\x04\x12\
    \x06\xb1\x01\x02\xae\x01.\n\r\n\x05\x04\x02\x02\x01\x06\x12\x04\xb1\x01\
    \x02\x17\n\r\n\x05\x04\x02\x02\x01\x01\x12\x04\xb1\x01\x18&\n\r\n\x05\
    \x04\x02\x02\x01\x03\x12\x04\xb1\x01)*\n\x89\x01\n\x04\x04\x02\x02\x02\
    \x12\x04\xb5\x01\x02\x1b\x1a{\x20Deprecated,\x20use\x20Details.effective\
    _severity\x20instead\n\x20The\x20severity\x20(e.g.,\x20distro\x20assigne\
    d\x20severity)\x20for\x20this\x20vulnerability.\n\n\x0f\n\x05\x04\x02\
    \x02\x02\x04\x12\x06\xb5\x01\x02\xb1\x01+\n\r\n\x05\x04\x02\x02\x02\x05\
    \x12\x04\xb5\x01\x02\x08\n\r\n\x05\x04\x02\x02\x02\x01\x12\x04\xb5\x01\t\
    \x16\n\r\n\x05\x04\x02\x02\x02\x03\x12\x04\xb5\x01\x19\x1a\n2\n\x02\x04\
    \x03\x12\x06\xb9\x01\0\xc3\x01\x01\x1a$\x20The\x20location\x20of\x20the\
    \x20vulnerability.\n\n\x0b\n\x03\x04\x03\x01\x12\x04\xb9\x01\x08\x1d\n\
    \xa5\x01\n\x04\x04\x03\x02\0\x12\x04\xbc\x01\x02\x15\x1a\x96\x01\x20Requ\
    ired.\x20The\x20CPE\x20URI\x20in\x20[cpe\x20format](https://cpe.mitre.or\
    g/specification/)\n\x20format.\x20Examples\x20include\x20distro\x20or\
    \x20storage\x20location\x20for\x20vulnerable\x20jar.\n\n\x0f\n\x05\x04\
    \x03\x02\0\x04\x12\x06\xbc\x01\x02\xb9\x01\x1f\n\r\n\x05\x04\x03\x02\0\
    \x05\x12\x04\xbc\x01\x02\x08\n\r\n\x05\x04\x03\x02\0\x01\x12\x04\xbc\x01\
    \t\x10\n\r\n\x05\x04\x03\x02\0\x03\x12\x04\xbc\x01\x13\x14\n6\n\x04\x04\
    \x03\x02\x01\x12\x04\xbf\x01\x02\x15\x1a(\x20Required.\x20The\x20package\
    \x20being\x20described.\n\n\x0f\n\x05\x04\x03\x02\x01\x04\x12\x06\xbf\
    \x01\x02\xbc\x01\x15\n\r\n\x05\x04\x03\x02\x01\x05\x12\x04\xbf\x01\x02\
    \x08\n\r\n\x05\x04\x03\x02\x01\x01\x12\x04\xbf\x01\t\x10\n\r\n\x05\x04\
    \x03\x02\x01\x03\x12\x04\xbf\x01\x13\x14\nE\n\x04\x04\x03\x02\x02\x12\
    \x04\xc2\x01\x02.\x1a7\x20Required.\x20The\x20version\x20of\x20the\x20pa\
    ckage\x20being\x20described.\n\n\x0f\n\x05\x04\x03\x02\x02\x04\x12\x06\
    \xc2\x01\x02\xbf\x01\x15\n\r\n\x05\x04\x03\x02\x02\x06\x12\x04\xc2\x01\
    \x02!\n\r\n\x05\x04\x03\x02\x02\x01\x12\x04\xc2\x01\")\n\r\n\x05\x04\x03\
    \x02\x02\x03\x12\x04\xc2\x01,-b\x06proto3\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
